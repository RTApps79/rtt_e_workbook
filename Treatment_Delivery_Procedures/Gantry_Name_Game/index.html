<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>LINAC Gantry Name Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
    body {
        margin: 0;
        overflow: hidden;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    canvas {
        display: block;
    }

    /* --- UI Panel --- */
    .ui-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 340px;
        background: rgba(247, 247, 247, 0.9);
        border: 1px solid #ccc;
        border-radius: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.18);
        z-index: 100;
        display: flex;
        flex-direction: column;
        backdrop-filter: blur(2px);
    }

    .ui-header {
        padding: 10px;
        background: #ececec;
        font-weight: 700;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        border-bottom: 1px solid #dcdcdc;
        text-align: center;
    }

    .ui-content {
        padding: 12px;
        max-height: 80vh;
        overflow-y: auto;
    }

    .ui-content button {
        display: block;
        width: 100%;
        margin: 6px 0;
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
    }
    
    .ui-content strong { 
        display: block; 
        margin-top: 10px; 
        margin-bottom: 6px; 
    }

    /* Game Specific Styles */
    #game-content h3 {
        text-align: center;
        margin-top: 0;
    }

    #score-display {
        text-align: center;
        font-size: 17px;
        font-weight: bold;
        margin-bottom: 8px;
        color: #333;
    }

    #game-status {
        font-size: 17px;
        font-weight: bold;
        margin-top: 8px;
        margin-bottom: 8px;
        min-height: 22px;
        text-align: center;
    }

    #next-question-button {
        background-color: #4CAF50;
        color: white;
        padding: 10px 18px;
        font-size: 15px;
        border: none;
        border-radius: 5px;
        display: block;
        margin: 10px auto;
    }

    #next-question-button:hover {
        background-color: #45a049;
    }

    #game-content .game-button-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
    }

    #game-content .game-button-grid button {
        margin: 0;
        padding: 8px 10px;
        font-size: 11.5px;
        border: 1px solid #bbb;
        background-color: #f9f9f9;
    }

    #game-content .game-button-grid button:hover {
        background-color: #e9e9e9;
    }

    #reset-game-button {
        background-color: #f44336;
        color: white;
    }

    /* --- Certificate (from Name Game) --- */
    #certificate-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        z-index: 9999;
        align-items: center;
        justify-content: center;
        padding: 16px;
    }

    #certificate-card {
        width: min(560px, 92vw);
        background: #fff;
        border: 8px solid #4CAF50;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        padding: 18px 20px 16px;
        text-align: center;
    }

    #certificate-card h2 {
        margin: 4px 0 8px;
        color: #2e7d32;
        font-size: 24px;
    }

    #certificate-card p {
        margin: 6px 0;
        line-height: 1.4;
        font-size: 15px;
    }

    #cert-name {
        width: 80%;
        max-width: 360px;
        padding: 8px 10px;
        font-size: 16px;
        border: 1px solid #bbb;
        border-radius: 6px;
    }

    .cert-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        margin-top: 12px;
    }

    .cert-actions button {
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background: #4CAF50;
        color: white;
        font-size: 14px;
    }

    .cert-actions button.secondary {
        background: #9e9e9e;
    }

    .cert-note {
        font-size: 12px;
        color: #555;
        margin-top: 6px;
    }

    /* --- Legend --- */
    #legend {
        position: absolute;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #ddd;
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 13px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.12);
        z-index: 50;
    }

    .dot {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 6px;
        vertical-align: middle;
    }
</style>

<script type="importmap">
{ 
    "imports": { 
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js", 
        "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/controls/OrbitControls.js" 
    } 
}
</script>
</head>
<body>

<div id="left-panel-container" class="ui-panel">
    <div id="game-tab" class="tab-content" style="display: block;">
        <div id="game-content" class="ui-content">
            <h3>Gantry Position Guessing Game</h3>
            <p style="font-size:13px; margin-top:0; color:#555; text-align: center;">
                The gantry will move to a random position. Select the button that matches its orientation category!
            </p>

            <div id="score-display">Score: 0</div>
            <button id="next-question-button" onclick="nextQuestion()">Start Game</button>
            <div id="game-status">Click "Start Game" to begin!</div>
            
            <hr style="margin: 12px 0;">
            <strong>Select the Gantry Orientation:</strong>
            
            <div class="game-button-grid">
                <button onclick="checkAnswer('AP')">AP / Superior</button>
                <button onclick="checkAnswer('PA')">PA / Inferior</button>
                <button onclick="checkAnswer('LT_LAT')">Lt Lateral</button>
                <button onclick="checkAnswer('RT_LAT')">Rt Lateral</button>
                <button onclick="checkAnswer('LAO')">LAO</button>
                <button onclick="checkAnswer('LPO')">LPO</button>
                <button onclick="checkAnswer('RPO')">RPO</button>
                <button onclick="checkAnswer('RAO')">RAO</button>
            </div>

            <hr style="margin: 12px 0;">
            <button id="reset-game-button" onclick="resetGame()">Clear & Reset Game</button>
        </div>
    </div>
</div>

<div id="certificate-overlay" role="dialog" aria-modal="true" aria-labelledby="cert-title">
    <div id="certificate-card">
        <h2 id="cert-title">Successful Completion Certificate</h2>
        <p>This certifies that</p>
        <p>
            <input id="cert-name" type="text" placeholder="Enter your name">
        </p>
        <p>has 
            successfully answered <strong>10</strong> questions correctly in the<br><strong>Gantry Position Guessing Game</strong>.</p>
        <p id="cert-date">Date: </p>
        <div class="cert-actions">
            <button onclick="downloadCertificatePNG()">Download PNG</button>
            <button onclick="shareCertificate()">Share</button>
            <button class="secondary" onclick="copyShareText()">Copy Share Text</button>
            <button class="secondary" onclick="closeCertificate()">Close</button>
        </div>
        <div class="cert-note">Tip: 
            enter your name before sharing/downloading.</div>
    </div>
</div>


<div id="legend">
    <span class="dot" style="background:#ff0000"></span>Room Lasers (Red)
    &nbsp;&nbsp; <span class="dot" style="background:#00ff00"></span>Tattoos (Green)
    &nbsp;&nbsp; <span class="dot" style="background:#8B0000"></span>Tumor (Maroon)
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// ===== Core Scene =====
let scene, renderer, controls, animationFrameId;
let camera;
// Materials - DEFINED FIRST to prevent initialization errors
const materials = {
    lightGray: new THREE.MeshStandardMaterial({ color: 0xd3d3d3 }),
    lightBlue: new THREE.MeshStandardMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.5 }),
    brightOrange: new THREE.MeshStandardMaterial({ color: 0xffa500 }),
    brightCyan: new THREE.MeshStandardMaterial({ color: 0x00ffff }),
    originalHead: new THREE.MeshStandardMaterial({ color: 0xc0c0c0, transparent: true, opacity: 0.55 }),
    lightBeige: new THREE.MeshStandardMaterial({ color: 0xf5f5dc }),
    originalCouch: new THREE.MeshStandardMaterial({ color: 0x909090 }),
    darkGray: new THREE.MeshStandardMaterial({ color: 0x505050 }),
    metallicGray: new THREE.MeshStandardMaterial({ color: 0xaaaaaa, 
        metalness: 0.5, roughness: 0.5 }),
    target: new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8, roughness: 0.3 }),
    klystron: new THREE.MeshStandardMaterial({ color: 0x778899, metalness: 0.3, roughness: 0.6 }),
    klystronWaveguide: new THREE.MeshStandardMaterial({ color: 0xb8860b, metalness: 0.7, roughness: 0.4 }),
    drivestand: new THREE.MeshStandardMaterial({ color: 0xeee8aa, transparent: true, opacity: 0.35, depthWrite: false }),
    patient: new THREE.MeshStandardMaterial({ color: 0xAD8C74, transparent: false, opacity: 1 }),
    tattoo: new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false }),
    tumor: new THREE.MeshStandardMaterial({ color: 0x8B0000, depthTest: false, transparent: true, opacity: 0.85 }),
    laser: new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false, transparent: true, opacity: 0.95 }),
    cone: new THREE.MeshStandardMaterial({ color: 0x808080, transparent: true, opacity: 0.6 })
};

// LINAC & Couch
let gantryRotatingAssembly;
let drivestand, connectingArm, acceleratorHousing, verticalArmL, head;
let couchGroup, couchSupportBase, couchAccordion, couchAccordionVisual, couchTopGroup, couchPlatform;
let initialCouchY;
// --- MODIFICATION ---
// Store the "aligned" couch positions as the baseline
let alignedCouchXPos, alignedCouchYPos, alignedCouchZPos;

// Imaging
let detectorPanel, detectorArm, detectorExtended = false;
let sideDetectorPanel, sideDetectorArm, sideDetectorShortArm, sideDetectorExtended = false;
let kvTubeGroup, kvTubeHousing, kvTubeHead, kvTubeArm, kvTubeShortArm;

// Beam shaping & accessories
let jawX1, jawX2, jawY1, jawY2, headSize = 0.6;
let electronCone, isConeAttached = false;
// Power & RF
let electronGun, waveguide, target, klystron;
let wgStaticVert, wgStaticHoriz, wgRotatingVert, wgRotatingHoriz;
// Patient model & alignment
let patientModel, tumor, tattooAnterior, tattooLeft, tattooRight;

// Lasers
let laserX, laserY, laserZ;

// Geometry/layout constants
const isocenterYTarget = 1.5;
const gantryPlaneZTarget = -1.0;
const couchSeparationOffset = 3.5;
const couchWidth = 0.8;
const couchPlatformHeight = 0.15;
const couchLength = 3.2;
const couchBaseHeight = 0.7;
const groundY = -0.05;
const newVerticalArmTotalLength = 1.6;
const verticalArmLSize = 0.4;
const acceleratorHousingLength = 2.0;
const detectorPanelWidth = 0.7, detectorPanelHeight = 0.6, detectorPanelThickness = 0.05, detectorArmRadius = 0.03;
const accordionGeometricHeight = 1.0;

// --- MODIFICATION ---
// Gantry arm radius (now static)
const baseGantryArmRadius = newVerticalArmTotalLength / 2; // 0.8

// Isocenter vectors
let machineIsocenter = new THREE.Vector3();
let laserIsocenter = new THREE.Vector3();
let isocenterOffset = new THREE.Vector3(0,0,0); // Default to zero offset

// ===== GAME LOGIC =====

// --- Game UI Elements ---
let gameStatusDisplay, scoreDisplay;

// --- Game State Variables ---
let score = 0;
const WIN_SCORE = 10;
let questionActive = false;
let gameCorrectAngle = null;
let gameCorrectCategoryId = null;
let gameCorrectCategoryName = null;
let lastGameCategoryId = null;

const gameAngleCategories = [
    { id: "AP",     name: "AP / Superior",    type: "cardinal", angle: 0 },
    { id: "PA",     name: "PA / Inferior",  type: "cardinal", angle: 180 },
    { id: "LT_LAT", name: "Lt Lateral",      type: "cardinal", angle: 90 },
    { id: "RT_LAT", name: "Rt Lateral",     type: "cardinal", angle: 270 },
    { id: "LAO",    name: "LAO",          type: "obliqueRange", range: [1, 89] },
    { id: "LPO",    name: "LPO",        type: "obliqueRange", range: [91, 179] },
    { id: "RPO",    name: "RPO",       type: "obliqueRange", range: [181, 269] },
    { id: "RAO",    name: "RAO",       type: "obliqueRange", range: [271, 359] }
];

// --- MODIFICATION ---
// Simplified to *only* rotate gantry and *enforce* static couch position
function setGantryAngle(clinicalAngleDeg) {
    const angleRad = THREE.MathUtils.degToRad(clinicalAngleDeg);
    gantryRotatingAssembly.rotation.z = -angleRad;

    // --- Enforce Static Aligned Couch Position ---
    couchGroup.position.y = alignedCouchYPos;
    couchTopGroup.position.x = alignedCouchXPos;
    couchTopGroup.position.z = alignedCouchZPos;
    
    // --- Gantry Arm is NOW STATIC ---
    // Ensure all components are at their *base* radius
    const newGantryArmRadius = baseGantryArmRadius;

    head.position.y = newGantryArmRadius;
    acceleratorHousing.position.y = newGantryArmRadius;
    
    // Adjust RF components (scale = 1)
    wgRotatingVert.position.y = newGantryArmRadius / 2;
    wgRotatingVert.scale.y = 1.0; // (base radius / base radius)
    wgRotatingHoriz.position.y = newGantryArmRadius;
    
    // Adjust detector arm (always uses base radius)
    setDetectorState(detectorExtended);
    setSideDetectorState(sideDetectorExtended); 

    // Update accordion
    constrainCouch(); 
}

function nextQuestion() {
    gameStatusDisplay.textContent = "Guess the orientation category!";
    gameStatusDisplay.style.color = "black";
    document.getElementById('next-question-button').textContent = "Next Question";

    // --- Prevent repeating category ---
    let randomIndex;
    let selectedCategory;
    do {
        randomIndex = Math.floor(Math.random() * gameAngleCategories.length);
        selectedCategory = gameAngleCategories[randomIndex];
    } while (selectedCategory.id === lastGameCategoryId && gameAngleCategories.length > 1);
    
    lastGameCategoryId = selectedCategory.id; // Store the new category
    // --- End prevention logic ---
    
    gameCorrectCategoryId = selectedCategory.id;
    gameCorrectCategoryName = selectedCategory.name;
    
    if (selectedCategory.type === "cardinal") {
        gameCorrectAngle = selectedCategory.angle;
    } else if (selectedCategory.type === "obliqueRange") {
        const min = selectedCategory.range[0];
        const max = selectedCategory.range[1];
        gameCorrectAngle = Math.floor(Math.random() * (max - min + 1)) + min;
    }

    setGantryAngle(gameCorrectAngle);
    questionActive = true;
}

function checkAnswer(selectedCategoryId) {
    if (!questionActive) {
        gameStatusDisplay.textContent = "Click 'Next Question' to start a new round.";
        gameStatusDisplay.style.color = "#FF8C00";
        return;
    }

    const selectedCategoryData = gameAngleCategories.find(cat => cat.id === selectedCategoryId);
    
    if (selectedCategoryId === gameCorrectCategoryId) {
        gameStatusDisplay.textContent = `Correct! It was ${gameCorrectCategoryName} (Angle: ${gameCorrectAngle}°).`;
        gameStatusDisplay.style.color = "#2E7D32"; // Dark Green
        score++;
        scoreDisplay.textContent = `Score: ${score}`;
        
        if (score === WIN_SCORE) {
            showCertificate();
        }
    } else {
        let incorrectMsg = `Incorrect. `;
        if (selectedCategoryData) {
            incorrectMsg += `You chose ${selectedCategoryData.name}. `;
        }
        incorrectMsg += `The correct answer was ${gameCorrectCategoryName} (Angle: ${gameCorrectAngle}°).`;
        gameStatusDisplay.textContent = incorrectMsg;
        gameStatusDisplay.style.color = "#C62828"; // Dark Red
    }
    
    questionActive = false;
}

function resetGame() {
    setGantryAngle(0); // Reset gantry visual and auto-aligns couch
    gameStatusDisplay.textContent = 'Click "Start Game" to begin!';
    gameStatusDisplay.style.color = "black";
    questionActive = false;
    gameCorrectAngle = null;
    gameCorrectCategoryId = null;
    gameCorrectCategoryName = null;
    lastGameCategoryId = null; // Reset category tracking
    score = 0;
    scoreDisplay.textContent = `Score: ${score}`;
    document.getElementById('next-question-button').textContent = "Start Game";
    closeCertificate();
}

// ===== Certificate helpers =====
function showCertificate() {
    const overlay = document.getElementById('certificate-overlay');
    const dateEl = document.getElementById('cert-date');
    dateEl.textContent = "Date: " + new Date().toLocaleDateString();
    overlay.style.display = 'flex';
    const nameInput = document.getElementById('cert-name');
    nameInput.focus();
}

function closeCertificate() {
    const overlay = document.getElementById('certificate-overlay');
    overlay.style.display = 'none';
}
window.closeCertificate = closeCertificate;

function buildCertificateCanvas(name, dateText) {
    const canvas = document.createElement('canvas');
    canvas.width = 1400;   // high-res PNG
    canvas.height = 1000;
    const ctx = canvas.getContext('2d');
    
    // Background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Border
    ctx.lineWidth = 16;
    ctx.strokeStyle = '#4CAF50';
    ctx.strokeRect(24, 24, canvas.width - 48, canvas.height - 48);
    
    // Title
    ctx.fillStyle = '#222';
    ctx.textAlign = 'center';
    ctx.font = 'bold 64px Arial';
    ctx.fillText('Certificate of Successful Completion', canvas.width / 2, 200);
    
    // Body
    ctx.font = '28px Arial';
    ctx.fillText('This certifies that', canvas.width / 2, 300);
    
    ctx.font = 'bold 56px Arial';
    ctx.fillText(name || 'Anonymous', canvas.width / 2, 380);
    
    ctx.font = '28px Arial';
    ctx.fillText('has correctly answered 10 questions in the', canvas.width / 2, 450);
    
    ctx.font = 'bold 36px Arial';
    ctx.fillText('Gantry Position Guessing Game', canvas.width / 2, 500);
    
    ctx.font = '28px Arial';
    ctx.fillText(dateText, canvas.width / 2, 580);
    
    // Small footer
    ctx.font = '20px Arial';
    ctx.fillStyle = '#444';
    ctx.fillText('Well done!', canvas.width / 2, 640);
    
    return canvas;
}

function downloadCertificatePNG() {
    const name = (document.getElementById('cert-name').value || 'Anonymous').trim();
    const dateText = document.getElementById('cert-date').textContent || ('Date: ' + new Date().toLocaleDateString());
    const canvas = buildCertificateCanvas(name, dateText);
    
    canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Gantry_Certificate_${name.replace(/\s+/g, '_')}.png`;
        a.click();
        URL.revokeObjectURL(url);
    }, 'image/png');
}
window.downloadCertificatePNG = downloadCertificatePNG;

async function copyShareText() {
    const name = (document.getElementById('cert-name').value || 'Anonymous').trim();
    const dateText = document.getElementById('cert-date').textContent || ('Date: ' + new Date().toLocaleDateString());
    const shareText =
`I just answered 10/10 correctly in the Gantry Position Guessing Game!
Name: ${name}
${dateText}`;
    
    try {
        await navigator.clipboard.writeText(shareText);
        alert('Shareable text copied to clipboard!');
    } catch {
        prompt('Copy your shareable result:', shareText);
    }
}
window.copyShareText = copyShareText;

async function shareCertificate() {
    const name = (document.getElementById('cert-name').value || 'Anonymous').trim();
    const dateText = document.getElementById('cert-date').textContent || ('Date: ' + new Date().toLocaleDateString());
    const shareText =
`I just answered 10/10 correctly in the Gantry Position Guessing Game!
Name: ${name}
${dateText}`;
    
    if (navigator.share) {
        try {
            await navigator.share({ title: 'Completion Certificate', text: shareText });
            return;
        } catch {
            // fall through to clipboard
        }
    }
    // Fallback: copy to clipboard
    try {
        await navigator.clipboard.writeText(shareText);
        alert('Share not supported here. Shareable text copied to clipboard!');
    } catch {
        prompt('Copy your shareable result:', shareText);
    }
}
window.shareCertificate = shareCertificate;
// ===== End Game Logic =====


// ===== Cleanup & Init =====
function cleanup() {
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    if(renderer) {
        renderer.dispose();
        if(renderer.domElement.parentElement) {
            renderer.domElement.parentElement.removeChild(renderer.domElement);
        }
    }
    
    if (scene) {
        scene.traverse(object => {
            if (object.geometry) object.geometry.dispose();
        });
    }

    for (const key in materials) {
        materials[key].dispose();
    }
    
    window.removeEventListener('resize', onWindowResize);
    
    scene = camera = controls = renderer = animationFrameId = null;
    gantryRotatingAssembly = head = couchPlatform = null;
}

if(window.cleanupPreviousScene) {
    window.cleanupPreviousScene();
}
window.cleanupPreviousScene = cleanup;

init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 120);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; 
    controls.dampingFactor = 0.08;
    controls.maxPolarAngle = Math.PI / 2;
    
    scene.add(new THREE.AmbientLight(0x808080));
    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(15, 20, 15);
    dir.castShadow = true; 
    dir.shadow.mapSize.set(2048,2048); 
    scene.add(dir);
    
    const groundPlane = new THREE.Mesh( new THREE.PlaneGeometry(40, 40), new THREE.MeshStandardMaterial({ color: 0xe0e0e0, side: THREE.DoubleSide }) );
    groundPlane.rotation.x = -Math.PI / 2;
    groundPlane.position.y = groundY;
    groundPlane.receiveShadow = true;
    scene.add(groundPlane);

    // Get Game UI Elements
    gameStatusDisplay = document.getElementById('game-status');
    scoreDisplay = document.getElementById('score-display');
    scoreDisplay.textContent = `Score: ${score}`;
    
    buildGantry();
    buildCouch();
    buildPatient();
    buildLasers();
    
    // Set lasers to true isocenter (no offset UI)
    laserIsocenter.copy(machineIsocenter).add(isocenterOffset);
    laserX.position.copy(laserIsocenter);
    laserY.position.copy(laserIsocenter);
    laserZ.position.copy(laserIsocenter);
    
    camera.position.set(8, isocenterYTarget + 3, machineIsocenter.z + 9);
    camera.lookAt(0, isocenterYTarget, machineIsocenter.z);
    controls.target.set(0, isocenterYTarget, machineIsocenter.z);
    controls.update();
    
    window.addEventListener('resize', onWindowResize);
    
    // --- MODIFICATION ---
    // Calculate the "aligned" patient position (v1.6 logic)
    
    // 1. Set temporary, reasonable couch positions to get world coordinates
    couchTopGroup.position.x = 0.0;
    couchTopGroup.position.z = 0.0;
    couchGroup.position.y = (couchBaseHeight / 2) + groundY + 0.25; // A reasonable starting Y

    // 2. Force update of world matrices to read tattoo positions
    scene.updateMatrixWorld(true); 

    // 3. Get the world positions of all three tattoos
    const tattooCenter = new THREE.Vector3();
    const posAnterior = new THREE.Vector3();
    const posLeft = new THREE.Vector3();
    const posRight = new THREE.Vector3();

    tattooAnterior.getWorldPosition(posAnterior);
    tattooLeft.getWorldPosition(posLeft);
    tattooRight.getWorldPosition(posRight);

    // 4. Calculate the average center for X and Z alignment
    //    Use the side tattoos (posLeft) for the Y alignment
    tattooCenter.add(posAnterior).add(posLeft).add(posRight).divideScalar(3);

    // 5. Calculate the required shifts
    const requiredShift = new THREE.Vector3(
        laserIsocenter.x - tattooCenter.x,
        laserIsocenter.y - posLeft.y, // Align Y to side tattoos
        laserIsocenter.z - tattooCenter.z
    );

    // 6. Store these "aligned" positions as the static baseline
    alignedCouchXPos = couchTopGroup.position.x + requiredShift.x;
    alignedCouchYPos = couchGroup.position.y + requiredShift.y;
    alignedCouchZPos = couchTopGroup.position.z + requiredShift.z;
    
    // 7. Apply the final static position
    couchTopGroup.position.x = alignedCouchXPos;
    couchGroup.position.y = alignedCouchYPos;
    couchTopGroup.position.z = alignedCouchZPos;
    
    // 8. Call setGantryAngle(0) to set initial state
    setGantryAngle(0);
    
    constrainCouch();
    // --- END MODIFICATION ---
}

function buildGantry() {
    const gantrySetupGroup = new THREE.Group();
    gantrySetupGroup.position.set(0, 0, gantryPlaneZTarget);
    scene.add(gantrySetupGroup);
    
    const drivestandHeight = isocenterYTarget + 0.3;
    const drivestandDepth = 0.8;
    drivestand = new THREE.Mesh(new THREE.BoxGeometry(0.8, drivestandHeight, drivestandDepth), materials.drivestand);
    const visualGap = 0.4;
    drivestand.position.set(0, (drivestandHeight / 2) + groundY, -(visualGap + drivestandDepth / 2));
    gantrySetupGroup.add(drivestand);
    enableShadows(drivestand);
    
    connectingArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, visualGap), materials.lightGray);
    connectingArm.position.set(0, isocenterYTarget, -visualGap / 2);
    gantrySetupGroup.add(connectingArm);
    enableShadows(connectingArm);
    
    gantryRotatingAssembly = new THREE.Group();
    gantryRotatingAssembly.position.set(0, isocenterYTarget, 0);
    gantrySetupGroup.add(gantryRotatingAssembly);
    enableShadows(gantryRotatingAssembly);
    window.gantryRotatingAssembly = gantryRotatingAssembly;
    
    verticalArmL = new THREE.Mesh(new THREE.BoxGeometry(verticalArmLSize, newVerticalArmTotalLength, verticalArmLSize), materials.lightBlue);
    gantryRotatingAssembly.add(verticalArmL);
    
    acceleratorHousing = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, acceleratorHousingLength), materials.lightBlue);
    acceleratorHousing.position.set(0, baseGantryArmRadius, acceleratorHousingLength / 2); // Use BASE radius
    gantryRotatingAssembly.add(acceleratorHousing);
    
    head = new THREE.Mesh(new THREE.BoxGeometry(headSize, headSize, headSize), materials.originalHead);
    head.position.set(0, baseGantryArmRadius, acceleratorHousingLength); // Use BASE radius
    gantryRotatingAssembly.add(head);
    
    head.updateWorldMatrix(true, false);
    machineIsocenter = head.getWorldPosition(new THREE.Vector3());
    machineIsocenter.y -= baseGantryArmRadius; // Use BASE radius
    
    const jawsGroup = new THREE.Group();
    head.add(jawsGroup);
    const jawThickness = 0.06;
    const jawDepth = 0.3;
    jawX1 = new THREE.Mesh(new THREE.BoxGeometry(jawThickness, headSize, jawDepth), materials.brightOrange);
    jawX2 = new THREE.Mesh(new THREE.BoxGeometry(jawThickness, headSize, jawDepth), materials.brightOrange);
    jawY1 = new THREE.Mesh(new THREE.BoxGeometry(headSize, jawThickness, jawDepth), materials.brightCyan);
    jawY2 = new THREE.Mesh(new THREE.BoxGeometry(headSize, jawThickness, jawDepth), materials.brightCyan);
    jawsGroup.add(jawX1, jawX2, jawY1, jawY2);
    updateJawVisuals({ x1: 5, x2: 5, y1: 5, y2: 5 }); // Set default 10x10 field
    
    detectorArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), materials.lightGray);
    detectorPanel = new THREE.Mesh(new THREE.BoxGeometry(detectorPanelWidth, detectorPanelHeight, detectorPanelThickness), materials.lightGray);
    gantryRotatingAssembly.add(detectorArm, detectorPanel);
    setDetectorState(false);
    
    const gunLength = 0.3, gunRadius = 0.15;
    electronGun = new THREE.Mesh(new THREE.CylinderGeometry(gunRadius, gunRadius * 0.8, gunLength, 16), materials.metallicGray);
    electronGun.rotation.x = Math.PI / 2;
    electronGun.position.set(0, 0, -acceleratorHousingLength / 2 - gunLength / 2);
    acceleratorHousing.add(electronGun);
    enableShadows(electronGun);
    
    const waveguideRadius = 0.05;
    const waveguideLength = acceleratorHousingLength - gunLength - 0.1;
    waveguide = new THREE.Mesh(new THREE.CylinderGeometry(waveguideRadius, waveguideRadius, waveguideLength, 16), materials.metallicGray);
    waveguide.rotation.x = Math.PI / 2;
    waveguide.position.set(0, 0, electronGun.position.z + gunLength / 2 + waveguideLength / 2);
    acceleratorHousing.add(waveguide);
    enableShadows(waveguide);
    
    const targetRadius = 0.08, targetThickness = 0.02;
    target = new THREE.Mesh(new THREE.CylinderGeometry(targetRadius, targetRadius, targetThickness, 16), materials.target);
    target.rotation.x = Math.PI / 2;
    target.position.set(0, 0, 0.1);
    head.add(target);
    enableShadows(target);
    
    const shortArmGeo = new THREE.BoxGeometry(0.15, 0.2, 0.15);
    sideDetectorShortArm = new THREE.Mesh(shortArmGeo, materials.originalCouch);
    kvTubeShortArm = new THREE.Mesh(shortArmGeo, materials.originalCouch);
    const kvOffset = 0.45;
    sideDetectorShortArm.position.set(-(verticalArmLSize / 2 + kvOffset), 0, 0);
    kvTubeShortArm.position.set(verticalArmLSize / 2 + kvOffset, 0, 0);
    gantryRotatingAssembly.add(sideDetectorShortArm, kvTubeShortArm);
    
    sideDetectorPanel = new THREE.Mesh(new THREE.BoxGeometry(detectorPanelWidth, detectorPanelHeight, detectorPanelThickness), materials.lightGray);
    sideDetectorArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), materials.lightGray);
    gantryRotatingAssembly.add(sideDetectorPanel, sideDetectorArm);
    
    kvTubeGroup = new THREE.Group();
    kvTubeHousing = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.5, 20), materials.metallicGray);
    kvTubeHead = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.1, 20), materials.originalCouch);
    kvTubeHead.position.y = 0.25;
    kvTubeGroup.add(kvTubeHousing, kvTubeHead);
    kvTubeArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), materials.lightGray);
    gantryRotatingAssembly.add(kvTubeGroup, kvTubeArm);
    setSideDetectorState(false);
    
    const coneHeight = 0.8;
    const coneSize = headSize * 0.7;
    electronCone = new THREE.Mesh(new THREE.BoxGeometry(coneSize, coneHeight, coneSize), materials.cone);
    electronCone.position.set(0, -(headSize / 2) - (coneHeight / 2), 0);
    head.add(electronCone);
    electronCone.visible = false;
    
    const klystronHeight = 0.6;
    klystron = new THREE.Mesh(new THREE.BoxGeometry(0.4, klystronHeight, 0.4), materials.klystron);
    klystron.position.set(drivestand.position.x, (drivestand.position.y - drivestandHeight / 2) + klystronHeight / 2, drivestand.position.z);
    gantrySetupGroup.add(klystron);
    enableShadows(klystron);
    
    const klystronWaveguideRadius = 0.04;
    const wgStatic_Y_Start = klystron.position.y + klystronHeight / 2;
    const wgStatic_Y_End = connectingArm.position.y;
    const wgStatic_Vert_Length = Math.abs(wgStatic_Y_End - wgStatic_Y_Start);
    wgStaticVert = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgStatic_Vert_Length > 0 ? wgStatic_Vert_Length : 0.01, 16), materials.klystronWaveguide);
    wgStaticVert.position.set(klystron.position.x, wgStatic_Y_Start + wgStatic_Vert_Length / 2, klystron.position.z);
    gantrySetupGroup.add(wgStaticVert);
    
    const wgStatic_Z_Start = klystron.position.z;
    const wgStatic_Z_End = connectingArm.position.z + visualGap / 2;
    const wgStatic_Horiz_Length = Math.abs(wgStatic_Z_End - wgStatic_Z_Start);
    wgStaticHoriz = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgStatic_Horiz_Length > 0 ? wgStatic_Horiz_Length : 0.01, 16), materials.klystronWaveguide);
    wgStaticHoriz.rotation.x = Math.PI / 2;
    wgStaticHoriz.position.set(klystron.position.x, wgStatic_Y_End, wgStatic_Z_Start + (wgStatic_Z_End - wgStatic_Z_Start) / 2);
    gantrySetupGroup.add(wgStaticHoriz);
    
    // Build RF components using BASE radius
    wgRotatingVert = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, baseGantryArmRadius > 0 ? baseGantryArmRadius : 0.01, 16), materials.klystronWaveguide);
    wgRotatingVert.position.set(0, baseGantryArmRadius / 2, 0);
    gantryRotatingAssembly.add(wgRotatingVert);
    
    const electronGunWorldPos = new THREE.Vector3();
    acceleratorHousing.updateMatrixWorld(true);
    electronGun.getWorldPosition(electronGunWorldPos);
    const electronGunLocalPosGRA = gantryRotatingAssembly.worldToLocal(electronGunWorldPos.clone());
    const wgRotating_Horiz_Z_Start = 0;
    const wgRotating_Horiz_Z_End = electronGunLocalPosGRA.z;
    const wgRotating_Horiz_Length_Actual = Math.abs(wgRotating_Horiz_Z_End - wgRotating_Horiz_Z_Start);
    wgRotatingHoriz = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgRotating_Horiz_Length_Actual > 0 ? wgRotating_Horiz_Length_Actual : 0.01, 16), materials.klystronWaveguide);
    wgRotatingHoriz.rotation.x = Math.PI / 2;
    wgRotatingHoriz.position.set(0, baseGantryArmRadius, (wgRotating_Horiz_Z_Start + wgRotating_Horiz_Z_End) / 2);
    gantryRotatingAssembly.add(wgRotatingHoriz);
}

function buildCouch() { 
    couchGroup = new THREE.Group();
    window.couchGroup = couchGroup; 
    initialCouchY = (couchBaseHeight/2) + groundY; 
    couchGroup.position.set(0, initialCouchY, gantryPlaneZTarget + couchSeparationOffset); 
    scene.add(couchGroup); 
    enableShadows(couchGroup);
    
    couchSupportBase = new THREE.Mesh(new THREE.BoxGeometry(couchWidth * 0.8, couchBaseHeight, couchLength * 0.5), materials.lightBeige); 
    couchSupportBase.position.y = 0; 
    couchGroup.add(couchSupportBase); 
    
    couchTopGroup = new THREE.Group();
    window.couchTopGroup = couchTopGroup; 
    couchTopGroup.position.y = (couchBaseHeight/2) + (couchPlatformHeight/2); 
    couchTopGroup.position.z = 0; 
    couchGroup.add(couchTopGroup); 
    
    couchPlatform = new THREE.Mesh(new THREE.BoxGeometry(couchWidth, couchPlatformHeight, couchLength), materials.originalCouch);
    couchTopGroup.add(couchPlatform); 
    
    couchAccordion = new THREE.Group(); 
    couchAccordion.position.set(couchGroup.position.x, groundY, couchGroup.position.z); 
    scene.add(couchAccordion); 
    enableShadows(couchAccordion);
    
    couchAccordionVisual = new THREE.Mesh(new THREE.BoxGeometry(couchWidth * 0.7, accordionGeometricHeight, couchLength * 0.4), materials.darkGray); 
    couchAccordionVisual.position.y = accordionGeometricHeight/2; 
    couchAccordion.add(couchAccordionVisual); 
    
    updateAccordion();
}

function buildPatient() { 
    patientModel = new THREE.Group(); 
    couchTopGroup.add(patientModel); 
    
    const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.26, 0.75, 20), materials.patient);
    torso.castShadow = true; 
    patientModel.add(torso); 
    
    const neck  = new THREE.Mesh(new THREE.CylinderGeometry(0.10, 0.10, 0.12, 16), materials.patient); 
    neck.position.set(0, 0.75/2 + 0.08, 0);
    patientModel.add(neck); 
    
    const headS = new THREE.Mesh(new THREE.SphereGeometry(0.14, 20, 20), materials.patient); 
    headS.position.set(0, neck.position.y + 0.12, 0); 
    headS.scale.set(0.8, 1, 1); 
    patientModel.add(headS);
    
    const armGeo = new THREE.CylinderGeometry(0.07, 0.06, 0.70, 12); 
    const leftArm = new THREE.Mesh(armGeo, materials.patient); 
    leftArm.position.set(-0.32, 0.0, 0); 
    patientModel.add(leftArm);
    
    const rightArm= new THREE.Mesh(armGeo, materials.patient); 
    rightArm.position.set( 0.32, 0.0, 0); 
    patientModel.add(rightArm); 
    
    const legGeo = new THREE.CylinderGeometry(0.12, 0.09, 0.85, 12);
    const leftLeg = new THREE.Mesh(legGeo, materials.patient); 
    leftLeg.position.set(-0.12, -0.85, 0); 
    patientModel.add(leftLeg); 
    
    const rightLeg= new THREE.Mesh(legGeo, materials.patient); 
    rightLeg.position.set( 0.12, -0.85, 0); 
    patientModel.add(rightLeg);
    
    // Position a default tumor and tattoos
    let tumorLocalOffset = new THREE.Vector3(0.05, 0.1, 0.02);
    tumor = new THREE.Mesh(new THREE.SphereGeometry(0.05, 24, 24), materials.tumor); 
    tumor.renderOrder = 2; 
    tumor.position.copy(tumorLocalOffset);
    patientModel.add(tumor); 
    
    const tatGeo = new THREE.SphereGeometry(0.012, 12, 12);
    tattooAnterior = new THREE.Mesh(tatGeo, materials.tattoo); 
    tattooLeft = new THREE.Mesh(tatGeo, materials.tattoo); 
    tattooRight = new THREE.Mesh(tatGeo, materials.tattoo);
    
    const torsoParams = { height: 0.75, radiusTop: 0.28, radiusBottom: 0.26 };
    // This calculation finds the radius at the patient's local Y=0 (mid-torso)
    const y_norm_tatt = (0 + torsoParams.height/2) / torsoParams.height;
    const radiusAtTattY = torsoParams.radiusBottom + (torsoParams.radiusTop - torsoParams.radiusBottom) * y_norm_tatt;
    tattooAnterior.position.set(0, 0, radiusAtTattY); // Anterior tattoo
    tattooLeft.position.set(-radiusAtTattY, 0, 0);   // Left tattoo
    tattooRight.position.set(radiusAtTattY, 0, 0);  // Right tattoo

    [tattooAnterior, tattooLeft, tattooRight].forEach(t => { t.renderOrder = 3; patientModel.add(t); }); 
    
    patientModel.rotation.x = -Math.PI/2;
    const patientOnCouchY = (couchPlatformHeight / 2) + 0.28 + 0.01; 
    // Patient model is centered in X, offset in Y and Z relative to couch top
    patientModel.position.set(0, patientOnCouchY, -0.3);
}

function buildLasers() { 
    const laserMaterial = materials.laser;
    const laserLen = 30, laserRadius = 0.01; 
    const geo = new THREE.CylinderGeometry(laserRadius, laserRadius, laserLen, 8); 
    
    laserX = new THREE.Mesh(geo, laserMaterial);
    laserX.rotation.z = Math.PI/2; 
    scene.add(laserX); 
    
    laserY = new THREE.Mesh(geo, laserMaterial); 
    scene.add(laserY); 
    
    laserZ = new THREE.Mesh(geo, laserMaterial); 
    laserZ.rotation.x = Math.PI/2; 
    scene.add(laserZ);
    
    [laserX, laserY, laserZ].forEach(l => { l.renderOrder = 10; }); 
}


// ===== LINAC Helper Functions (Kept for scene building) =====

function updateJawVisuals(jawPositions) {
    const x1_m = -jawPositions.x1 / 100;
    const x2_m = jawPositions.x2 / 100;
    const y1_m = jawPositions.y1 / 100;
    const y2_m = -jawPositions.y2 / 100;
    
    jawX1.position.x = x1_m;
    jawX2.position.x = x2_m;
    jawY1.position.y = y1_m;
    jawY2.position.y = y2_m;

    const fsX_m = x2_m - x1_m;
    jawY1.geometry.dispose();
    jawY1.geometry = new THREE.BoxGeometry(fsX_m, jawY1.geometry.parameters.height, jawY1.geometry.parameters.depth);
    jawY2.geometry.dispose();
    jawY2.geometry = new THREE.BoxGeometry(fsX_m, jawY2.geometry.parameters.height, jawY2.geometry.parameters.depth);
    jawY1.position.x = x1_m + fsX_m / 2;
    jawY2.position.x = x1_m + fsX_m / 2;

    const fsY_m = y1_m - y2_m;
    jawX1.geometry.dispose();
    jawX1.geometry = new THREE.BoxGeometry(jawX1.geometry.parameters.width, fsY_m, jawX1.geometry.parameters.depth);
    jawX2.geometry.dispose();
    jawX2.geometry = new THREE.BoxGeometry(jawX2.geometry.parameters.width, fsY_m, jawX2.geometry.parameters.depth);
    jawX1.position.y = y2_m + fsY_m / 2;
    jawX2.position.y = y2_m + fsY_m / 2;
}

// --- MODIFICATION ---
// Removed dynamic radius parameter, always uses baseGantryArmRadius
function setDetectorState(isExtended) { 
    detectorExtended = isExtended;
    const gantryArmRadius = baseGantryArmRadius; // Always use base radius
    if (isExtended) { 
        const isoLocal = gantryRotatingAssembly.worldToLocal(machineIsocenter.clone()); 
        const armStartPos = new THREE.Vector3(0, -gantryArmRadius, 0); 
        const panelPos = new THREE.Vector3(0, armStartPos.y, isoLocal.z); 
        const armVector = new THREE.Vector3().subVectors(panelPos, armStartPos); 
        const armLength = armVector.length(); 
        detectorArm.visible = true;
        detectorPanel.visible = true; 
        detectorArm.geometry.dispose(); 
        detectorArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, armLength, 16); 
        detectorArm.position.copy(armStartPos).add(armVector.clone().multiplyScalar(0.5)); 
        detectorArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), armVector.clone().normalize()); 
        detectorPanel.position.copy(panelPos);
        const headWorldPos = head.getWorldPosition(new THREE.Vector3()); 
        const gantryRight = new THREE.Vector3(1, 0, 0).applyQuaternion(gantryRotatingAssembly.quaternion); 
        detectorPanel.up.copy(gantryRight); 
        detectorPanel.lookAt(headWorldPos); 
    } else { 
        detectorArm.visible = false;
        detectorPanel.visible = true; 
        detectorPanel.rotation.set(0, 0, 0); 
        detectorPanel.position.set(0, -gantryArmRadius, verticalArmLSize / 2 + detectorPanelThickness / 2);
    } 
}

function setSideDetectorState(isExtended) { 
    sideDetectorExtended = isExtended; 
    const allImagerParts = [sideDetectorPanel, sideDetectorArm, kvTubeGroup, kvTubeArm];
    if (isExtended) { 
        allImagerParts.forEach(p => p.visible = true); 
        const isoLocal = gantryRotatingAssembly.worldToLocal(machineIsocenter.clone()); 
        const detectorStartPos = sideDetectorShortArm.position.clone();
        const detectorEndPos = new THREE.Vector3(detectorStartPos.x, detectorStartPos.y, isoLocal.z); 
        const detectorVector = new THREE.Vector3().subVectors(detectorEndPos, detectorStartPos); 
        const detectorArmLength = detectorVector.length(); 
        sideDetectorArm.geometry.dispose();
        sideDetectorArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, detectorArmLength, 16); 
        sideDetectorArm.position.copy(detectorStartPos).add(detectorVector.clone().multiplyScalar(0.5)); 
        sideDetectorArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), detectorVector.clone().normalize()); 
        sideDetectorPanel.position.copy(detectorEndPos); 
        sideDetectorPanel.rotation.set(0, Math.PI / 2, 0);
        const tubeStartPos = kvTubeShortArm.position.clone(); 
        const tubeEndPos = new THREE.Vector3(tubeStartPos.x, tubeStartPos.y, isoLocal.z); 
        const tubeVector = new THREE.Vector3().subVectors(tubeEndPos, tubeStartPos);
        const tubeArmLength = tubeVector.length(); 
        kvTubeArm.geometry.dispose(); 
        kvTubeArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, tubeArmLength, 16); 
        kvTubeArm.position.copy(tubeStartPos).add(tubeVector.clone().multiplyScalar(0.5)); 
        kvTubeArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tubeVector.clone().normalize()); 
        kvTubeGroup.position.copy(tubeEndPos);
        kvTubeGroup.rotation.set(Math.PI / 2, Math.PI, 0); 
    } else { 
        allImagerParts.forEach(p => p.visible = false); 
    } 
}

function constrainCouch(){ 
    // This function now just updates the accordion, as the position is locked
    // by setGantryAngle.
    updateAccordion(); 
}

function enableShadows(o){ 
    o.castShadow = true; 
    o.receiveShadow = true;
    if (o.children) o.children.forEach(enableShadows); 
}

function updateAccordion(){ 
    // This function must still read the *current* couch Y, even if it's static
    const baseBottomWorldY = couchGroup.position.y - (couchBaseHeight/2); 
    const h = Math.max(0.01, baseBottomWorldY - groundY);
    couchAccordionVisual.scale.y = h / accordionGeometricHeight; 
    couchAccordionVisual.position.y = h/2; 
    couchAccordion.position.x = couchGroup.position.x; 
    couchAccordion.position.z = couchGroup.position.z; 
}

function onWindowResize(){ 
    if(!camera || !renderer) return; 
    camera.aspect = window.innerWidth / window.innerHeight; 
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight); 
}

function animate(){ 
    animationFrameId = requestAnimationFrame(animate); 
    if(renderer) { 
        controls.update(); 
        renderer.render(scene, camera);
    } 
}

// ===== Global Window Assignments for Game =====
window.nextQuestion = nextQuestion;
window.checkAnswer = checkAnswer;
window.resetGame = resetGame;

</script>
</body>
</html>
