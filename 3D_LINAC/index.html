<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Integrated LINAC Alignment Simulator & Training</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
canvas { display: block; }

/* --- UI Panels --- */
.ui-panel {
position: absolute; top: 20px; width: 340px; background: rgba(247,247,247,0.9);
border: 1px solid #ccc; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.18);
z-index: 100; display: flex; flex-direction: column; backdrop-filter: blur(2px);
transition: transform 0.4s ease-in-out;
}
.ui-header { padding: 10px; background: #ececec; font-weight: 700; cursor: move;
border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom: 1px solid #dcdcdc; text-align: center; }
.ui-content { padding: 12px; max-height: 80vh; overflow-y: auto; }
.ui-content button { display: block; width: 100%; margin: 6px 0; padding: 8px 12px; font-size: 14px; cursor: pointer; }
.ui-content strong { display: block; margin-top: 10px; margin-bottom: 6px; }

/* Console Specifics */
#console-window { right: 20px; }
#console-window.hidden { transform: translateX(calc(100% + 40px)); }

/* Alignment & Learning Specifics */
#left-panel-container {
position: absolute;
top: 20px;
left: 20px;
width: 340px;
z-index: 100;
transition: transform 0.4s ease-in-out;
}
#left-panel-container.hidden { transform: translateX(calc(-100% - 40px)); }

.tab-buttons { display: flex; border-bottom: 1px solid #ccc; }
.tab-button { flex: 1; padding: 10px; background: #e0e0e0; border: none; cursor: pointer; font-weight: bold; border-top-left-radius: 10px; border-top-right-radius: 10px; }
.tab-button.active { background: #f7f7f7; border-bottom: 1px solid #f7f7f7; margin-bottom: -1px; }
.tab-content { display: none; }
.tab-content.active { display: block; }

#align-content .row, #console-content .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 6px; }
#align-content .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 6px; }
#align-content .row-iso { display: grid; grid-template-columns: 20px 1fr 50px; gap: 5px; align-items: center; margin-bottom: 4px; }
#align-content .row-iso label { font-weight: bold; }
#align-content .row-iso input { width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px; }
#align-content button { width: 100%; padding: 8px 12px; font-size: 13px; cursor: pointer; }
#alignmentMessage { font-weight: 600; min-height: 2.2em; margin-top: 8px; }

/* --- Digital Readouts --- */
.readout-grid { display: grid; grid-template-columns: auto 1fr; gap: 4px 10px; background: #e9e9e9; padding: 8px; border-radius: 6px; font-size: 13px;
font-family: 'Courier New', Courier, monospace; }
.readout-label { font-weight: bold; text-align: right; }
.readout-value { background: #fff; padding: 2px 5px; border-radius: 3px; border: 1px solid #ddd; }

/* --- Console Toggle Button --- */
#console-toggle-button { position: absolute; top: 20px; right: 360px; width: 40px; height: 40px; background: #333; color: white; border: none;
border-radius: 10px 0 0 10px; cursor: pointer; z-index: 101; display: flex; align-items: center; justify-content: center; font-size: 20px;
transition: right 0.4s ease-in-out, background-color 0.2s; }
#console-toggle-button:hover { background: #555; }

/* --- Learning Center --- */
#learning-content .module-button { background-color: #f0f0f0; border: 1px solid #ccc; }
#learning-content .module-button:hover { background-color: #e0e0e0; }
#activity-view { margin-top: 15px; }
#activity-title { font-size: 1.1em; font-weight: bold; margin-bottom: 5px; }
#activity-objective { font-size: 0.9em; margin-bottom: 10px; color: #555; }
#activity-instruction { font-size: 1em; font-weight: bold; color: #005a9c; min-height: 40px; background: #e3f2fd; padding: 8px; border-radius: 4px; border: 1px solid #bbdefb;
}
#activity-feedback { min-height: 2em; margin-top: 10px; font-weight: bold; }
#activity-progress-bar { width: 100%; background-color: #e0e0e0; border-radius: 5px; overflow: hidden; height: 10px; margin-top: 10px; }
#activity-progress { width: 0%; height: 100%; background-color: #4caf50; transition: width 0.3s; }

/* Floating labels for parts */
.component-label { position: absolute; background: rgba(0,0,0,0.7); color: #fff; padding: 3px 7px; border-radius: 4px; font-size: 12px; pointer-events: none; transform: translate(-50%, -110%);
white-space: nowrap; z-index: 5; visibility: hidden; }
#label-axisX { color: #FF7777; } #label-axisY { color: #77FF77; } #label-axisZ { color: #7777FF; }

/* Legend pill */
#legend { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.9); border: 1px solid #ddd; border-radius: 999px;
padding: 6px 12px; font-size: 13px; box-shadow: 0 4px 10px rgba(0,0,0,0.12); z-index: 50; }
.dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
</style>

<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js", "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/controls/OrbitControls.js" } }
</script>
</head>
<body>
<button id="console-toggle-button">«</button>

<div id="console-window" class="ui-panel">
<div id="console-header" class="ui-header">LINAC Console</div>
<div id="console-content" class="ui-content">
<strong>Digital Readouts</strong>
<div class="readout-grid">
<div class="readout-label">Gantry:</div><div id="readout-gantry" class="readout-value">0.0°</div>
<div class="readout-label">Jaws X1/X2:</div><div id="readout-jawsX" class="readout-value">5.0 / 5.0 cm</div>
<div class="readout-label">Jaws Y1/Y2:</div><div id="readout-jawsY" class="readout-value">5.0 / 5.0 cm</div>
<div class="readout-label">Couch Vrt:</div><div id="readout-couchY" class="readout-value">0.0 cm</div>
<div class="readout-label">Couch Lng:</div><div id="readout-couchZ" class="readout-value">0.0 cm</div>
<div class="readout-label">Couch Lat:</div><div id="readout-couchX" class="readout-value">0.0 cm</div>
</div>
<hr>
<strong>Gantry</strong>
<div class="row">
    <button onclick="rotateGantry(false, 5)">⇦ Coarse (5°)</button>
    <button onclick="rotateGantry(true, 5)">Coarse (5°) ⇨</button>
</div>
<div class="row">
    <button onclick="rotateGantry(false, 0.5)">⇦ Fine (0.5°)</button>
    <button onclick="rotateGantry(true, 0.5)">Fine (0.5°) ⇨</button>
</div>
<hr>
<strong>Collimator</strong>
<div>
    Step Size (cm):
    <input type="radio" id="step10" name="jaw_step" value="1.0" checked style="margin-left: 5px;">
    <label for="step10">1.0</label>
    <input type="radio" id="step1" name="jaw_step" value="0.1" style="margin-left: 10px;">
    <label for="step1">0.1</label>
</div>
<div style="margin-top: 8px;">
    Active Jaw:
    <input type="radio" id="jawX1" name="active_jaw" value="x1" checked style="margin-left: 5px;"> <label for="jawX1">X1</label>
    <input type="radio" id="jawX2" name="active_jaw" value="x2" style="margin-left: 8px;"> <label for="jawX2">X2</label>
    <input type="radio" id="jawY1" name="active_jaw" value="y1" style="margin-left: 8px;"> <label for="jawY1">Y1</label>
    <input type="radio" id="jawY2" name="active_jaw" value="y2" style="margin-left: 8px;"> <label for="jawY2">Y2</label>
</div>
<div class="row" style="margin-top: 8px;">
    <button onclick="moveSelectedJaw(-1)">Move − (In)</button>
    <button onclick="moveSelectedJaw(1)">Move + (Out)</button>
</div>
<hr>
<strong>Couch</strong>
<div style="margin-bottom: 8px;">
    Step Size (cm):
    <input type="radio" id="couch_step_coarse" name="couch_step" value="5.0" checked style="margin-left: 5px;">
    <label for="couch_step_coarse">5.0</label>
    <input type="radio" id="couch_step_fine" name="couch_step" value="0.5" style="margin-left: 10px;">
    <label for="couch_step_fine">0.5</label>
</div>
<button onclick="moveCouch(true)">Couch ↑ (+Y)</button>
<button onclick="moveCouch(false)">Couch ↓ (-Y)</button>
<button onclick="moveCouchLongitudinal(true)">Couch In (-Z)</button>
<button onclick="moveCouchLongitudinal(false)">Couch Out (+Z)</button>
<button onclick="moveCouchLateral(false)">Couch &larr; (−X)</button>
<button onclick="moveCouchLateral(true)">Couch &rarr; (+X)</button>
<hr>
<strong>Imaging</strong>
<button id="detectorToggleButton" onclick="toggleDetector()">Extend MV Imager</button>
<button id="sideDetectorToggleButton" onclick="toggleSideDetector()">Extend kV Imagers</button>
<hr>
<strong>Accessories</strong>
<button id="coneToggleButton" onclick="toggleElectronCone()">Attach Electron Cone</button>
<hr>
<button onclick="toggleLabels()">Toggle Labels</button>
</div>
</div>

<div id="left-panel-container">
<div class="ui-panel">
<div class="tab-buttons">
<button class="tab-button active" onclick="openTab(event, 'learning-tab')">Learning Center</button>
<button class="tab-button" onclick="openTab(event, 'align-tab')">Alignment</button>
</div>
<div id="learning-tab" class="tab-content active">
<div id="learning-content" class="ui-content">
<strong>Beginner Activities</strong>
<p style="font-size:13px; margin-top:0; color:#555;">Select a module to begin a self-guided activity.</p>
<button class="module-button" onclick="LearningModule.startActivity('scavengerHunt')">1. Machine Anatomy Scavenger Hunt</button>
<button class="module-button" onclick="LearningModule.startActivity('coordinates')">2. Understanding Machine Coordinates</button>
<button class="module-button" onclick="LearningModule.startActivity('alignment')">3. Basic Patient Alignment</button>

<strong>Intermediate Activities</strong>
<button class="module-button" onclick="LearningModule.startActivity('couchMatching')">4. Couch Position Matching</button>
<button class="module-button" onclick="LearningModule.startActivity('gantryCollimator')">5. Gantry & Collimator Setup</button>

<div id="activity-view" style="display:none;">
<hr>
<h3 id="activity-title"></h3>
<p id="activity-objective"></p>
<div id="activity-instruction"></div>
<div id="activity-feedback"></div>
<div id="activity-progress-bar"><div id="activity-progress"></div></div>
<button onclick="LearningModule.exitActivity()" style="margin-top:10px; background-color: #f44336; color:white;">Exit Activity</button>
</div>
</div>
</div>
<div id="align-tab" class="tab-content">
<div id="align-content" class="ui-content">
<div style="font-size:12px; opacity:.9; margin-bottom:6px;">Goal: Align patient tattoos to room lasers at isocenter.</div>
<div class="row3">
<button onclick="nudgePatient(-1,0,0)">X− (Lat)</button>
<button onclick="nudgePatient(0,1,0)">Y+ (Up)</button>
<button onclick="nudgePatient(1,0,0)">X+ (Lat)</button>
</div>
<div class="row3">
<button onclick="nudgePatient(0,0,-1)">Z− (In)</button>
<button onclick="checkAlignment()">Check Alignment</button>
<button onclick="nudgePatient(0,0,1)">Z+ (Out)</button>
</div>
<hr style="margin: 10px 0;">
<div style="font-size:12px; opacity:.9; margin-bottom:6px;">Isocenter/Laser Adjustment (cm):</div>
<div class="row-iso">
<label for="isoOffsetX">X:</label>
<input type="number" id="isoOffsetX" value="0" step="0.1" onchange="updateIsocenterOffset()">
<span>cm</span>
</div>
<div class="row-iso">
<label for="isoOffsetY">Y:</label>
<input type="number" id="isoOffsetY" value="0" step="0.1" onchange="updateIsocenterOffset()">
<span>cm</span>
</div>
<div class="row-iso">
<label for="isoOffsetZ">Z:</label>
<input type="number" id="isoOffsetZ" value="0" step="0.1" onchange="updateIsocenterOffset()">
<span>cm</span>
</div>
<hr style="margin: 10px 0;">
<div class="row">
<button onclick="newCase()">New Random Case</button>
<button onclick="centerCouch()"><span>Auto‑Center Couch</span></button>
</div>
<div id="alignmentMessage">Use couch/nudge controls to bring tattoos to laser lines.</div>
</div>
</div>
</div>
</div>

<div id="label-drivestand" class="component-label">Drivestand</div>
<div id="label-connectingArm" class="component-label">Connecting Arm</div>
<div id="label-acceleratorHousing" class="component-label">Accelerator Housing</div>
<div id="label-verticalArmL" class="component-label">Vertical Arm</div>
<div id="label-head" class="component-label">Head</div>
<div id="label-couchBase" class="component-label">Couch Base</div>
<div id="label-couchTop" class="component-label">Couch Top</div>
<div id="label-couchAccordion" class="component-label">Accordion</div>
<div id="label-detectorPanel" class="component-label">MV Detector Panel</div>
<div id="label-sideDetectorPanel" class="component-label">kV Detector Panel</div>
<div id="label-kvTube" class="component-label">kV X-Ray Tube</div>
<div id="label-electronCone" class="component-label">Electron Cone</div>
<div id="label-axisX" class="component-label">X</div>
<div id="label-axisY" class="component-label">Y</div>
<div id="label-axisZ" class="component-label">Z</div>
<div id="label-electronGun" class="component-label">Electron Gun</div>
<div id="label-waveguide" class="component-label">Waveguide (Acc.)</div>
<div id="label-target" class="component-label">Target</div>
<div id="label-klystron" class="component-label">Klystron</div>
<div id="label-klystronWaveguide" class="component-label">Waveguide (Klystron)</div>

<div id="legend">
<span class="dot" style="background:#ff0000"></span>Room Lasers (Red)
&nbsp;&nbsp; <span class="dot" style="background:#00ff00"></span>Tattoos (Green)
&nbsp;&nbsp; <span class="dot" style="background:#8B0000"></span>Tumor (Maroon)
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// ===== Core Scene =====
let camera, scene, renderer, controls;

// LINAC & Couch
let gantryRotatingAssembly;
let drivestand, connectingArm, acceleratorHousing, verticalArmL, head;
let couchGroup, couchSupportBase, couchAccordion, couchAccordionVisual, couchTopGroup, couchPlatform;
let initialCouchY; // For readout calculation

// Imaging
let detectorPanel, detectorArm, detectorExtended = false;
let sideDetectorPanel, sideDetectorArm, sideDetectorShortArm, sideDetectorExtended = false;
let kvTubeGroup, kvTubeHousing, kvTubeHead, kvTubeArm, kvTubeShortArm;

// Beam shaping & accessories
let jawX1, jawX2, jawY1, jawY2, headSize = 0.6;
// NEW CONVENTION: All values are positive, representing distance from the central axis.
let jawPositions = { x1: 5, x2: 5, y1: 5, y2: 5 }; // in cm.
let electronCone, isConeAttached = false;

// Power & RF
let electronGun, waveguide, target, klystron;
let wgStaticVert, wgStaticHoriz, wgRotatingVert, wgRotatingHoriz;

// Patient model & alignment
let patientModel, tumor, tattooAnterior, tattooLeft, tattooRight;
const patientMat = new THREE.MeshStandardMaterial({ color: 0xAD8C74, transparent: false, opacity: 1 });
const tattooMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false });
const tumorMat  = new THREE.MeshStandardMaterial({ color: 0x8B0000, depthTest: false, transparent: true, opacity: 0.85 });

// Lasers
let laserX, laserY, laserZ;

// UI & Readouts
const alignmentMessageElement = document.getElementById('alignmentMessage');
let readoutGantry, readoutJawsX, readoutJawsY, readoutCouchX, readoutCouchY, readoutCouchZ;

// Labels
const labels = {};
const labeledObjects = [];
let labelsVisible = false;

// Geometry/layout constants
const isocenterYTarget = 1.5;
const gantryPlaneZTarget = -1.0;
const couchSeparationOffset = 3.5;
const couchWidth = 0.8;
const couchPlatformHeight = 0.15;
const couchLength = 3.2;
const couchBaseHeight = 0.7;
const groundY = -0.05;
const newVerticalArmTotalLength = 1.6;
const verticalArmLSize = 0.4;
const acceleratorHousingLength = 2.0;
const detectorPanelWidth = 0.7, detectorPanelHeight = 0.6, detectorPanelThickness = 0.05, detectorArmRadius = 0.03;
const accordionGeometricHeight = 1.0;

// Alignment state
const MOVE_STEP = 0.001; // meters for fine nudge
const ALIGNMENT_TOLERANCE = 0.01; // 1 cm
let tumorLocalOffset = new THREE.Vector3();

// Isocenter vectors
let machineIsocenter = new THREE.Vector3(); // The "true" isocenter of the machine
let laserIsocenter = new THREE.Vector3();   // The position of the lasers, adjustable by user
let isocenterOffset = new THREE.Vector3();  // User-defined offset in meters

// Materials
const lightGrayMat = new THREE.MeshStandardMaterial({ color: 0xd3d3d3 });
const lightBlueMat = new THREE.MeshStandardMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.5 });
const brightOrangeMat = new THREE.MeshStandardMaterial({ color: 0xffa500 });
const brightCyanMat = new THREE.MeshStandardMaterial({ color: 0x00ffff });
const transparentLightGrayMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, transparent: true, opacity: 0.55 });
const lightBeigeMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc });
const mediumGrayMat = new THREE.MeshStandardMaterial({ color: 0x909090 });
const darkGrayMatMaterial = new THREE.MeshStandardMaterial({ color: 0x505050 });
const metallicGrayMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.5, roughness: 0.5 });
const targetMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8, roughness: 0.3 });
const klystronMat = new THREE.MeshStandardMaterial({ color: 0x778899, metalness: 0.3, roughness: 0.6 });
const klystronWaveguideMat = new THREE.MeshStandardMaterial({ color: 0xb8860b, metalness: 0.7, roughness: 0.4 });
const drivestandMaterial = new THREE.MeshStandardMaterial({ color: 0xeee8aa, transparent: true, opacity: 0.35, depthWrite: false });

// ===== LEARNING MODULE =====
const LearningModule = {
currentActivity: null,
currentStep: 0,
isChecking: false, // Flag to prevent rapid-fire checks
clicksDone: 0,
activities: {
scavengerHunt: {
title: "Anatomy Scavenger Hunt",
objective: "To identify major LINAC components by clicking on them.",
steps: [
{ instruction: "Find and click on the: Klystron", target: "Klystron" },
{ instruction: "Find and click on the: Accelerator Housing", target: "Accelerator Housing" },
{ instruction: "Find and click on the: Treatment Head", target: "Head" },
{ instruction: "Find and click on the: MV Detector Panel", target: "MV Detector Panel" }
]
},
coordinates: {
title: "Machine Coordinates",
objective: "To understand couch movements and their clinical terms.",
steps: [
{ instruction: "Move the couch IN (Superior) 3 times", target: { axis: 'Z', direction: true, clicksRequired: 3 } },
{ instruction: "Move the couch OUT (Inferior) 3 times", target: { axis: 'Z', direction: false, clicksRequired: 3 } },
{ instruction: "Move the couch RIGHT (Patient's Right) 3 times", target: { axis: 'X', direction: true, clicksRequired: 3 } },
{ instruction: "Move the couch LEFT (Patient's Left) 3 times", target: { axis: 'X', direction: false, clicksRequired: 3 } },
{ instruction: "Move the couch UP (Anterior) 3 times", target: { axis: 'Y', direction: true, clicksRequired: 3 } },
{ instruction: "Move the couch DOWN (Posterior) 3 times", target: { axis: 'Y', direction: false, clicksRequired: 3 } }
]
},
alignment: {
title: "Basic Patient Alignment",
objective: "To align the patient tattoos to the room lasers.",
steps: [ { instruction: "Click 'New Random Case', then use the couch controls to align the green tattoos to the red lasers. Click 'Check Alignment' when done."
} ]
},
couchMatching: {
title: "Couch Position Matching",
objective: "To accurately move the couch to specific coordinates based on calculated shifts.",
steps: [
{ instruction: "A setup requires the Couch Lat (X) to be at 5.0 cm. Use the couch controls to match this value.", target: { parameter: "couchLat", value: 5.0, tolerance: 0.3 } },
{ instruction: "Next, move the Couch Lng (Z) to -10.0 cm.", target: { parameter: "couchLng", value: -10.0, tolerance: 0.3 } },
{ instruction: "Finally, adjust the Couch Vrt (Y) to 2.5 cm.", target: { parameter: "couchVrt", value: 2.5, tolerance: 0.3 } }
]
},
gantryCollimator: {
title: "Gantry & Collimator Setup",
objective: "To set the gantry angle and collimator field size to match treatment parameters.",
steps: [
{ instruction: "Rotate the gantry to 90.0 degrees.", target: { parameter: "gantry", value: 90.0, tolerance: 0.3 } },
{ instruction: "Set the field to 15.0 cm (X) by 10.0 cm (Y).", target: { parameter: "fieldSize", valueX: 15.0, valueY: 10.0, tolerance: 0.1 } },
{ instruction: "Rotate the gantry to 270.0 degrees.", target: { parameter: "gantry", value: 270.0, tolerance: 0.3 } },
{ instruction: "Set an asymmetric field of 8.0 cm (X) by 12.0 cm (Y).", target: { parameter: "fieldSize", valueX: 8.0, valueY: 12.0, tolerance: 0.1 } }
]
}
},

startActivity(activityName) {
this.currentActivity = this.activities[activityName];
this.currentStep = 0;
this.clicksDone = 0;
document.getElementById('activity-view').style.display = 'block';
document.getElementById('activity-title').textContent = this.currentActivity.title;
document.getElementById('activity-objective').textContent = this.currentActivity.objective;
this.updateStep();

if (activityName === 'couchMatching' || activityName === 'gantryCollimator') {
    // Reset relevant machine state for a clean start
    couchTopGroup.position.x = 0;
    couchTopGroup.position.z = 0;
    couchGroup.position.y = initialCouchY;
    constrainCouch();

    gantryRotatingAssembly.rotation.z = 0;

    jawPositions = { x1: 5, x2: 5, y1: 5, y2: 5 };
    updateJawVisuals();
    
    updateReadouts();
}

if (activityName === 'scavengerHunt') {
    toggleLabels(false);
    renderer.domElement.addEventListener('click', this.onCanvasClick, false);
}
},

exitActivity() {
document.getElementById('activity-view').style.display = 'none';
this.currentActivity = null;
renderer.domElement.removeEventListener('click', this.onCanvasClick, false);
},

updateStep() {
if (!this.currentActivity) return;
this.clicksDone = 0;
const progress = (this.currentStep / this.currentActivity.steps.length) * 100;
document.getElementById('activity-progress').style.width = `${progress}%`;
if (this.currentStep >= this.currentActivity.steps.length) {
    this.completeActivity();
    return;
}
const step = this.currentActivity.steps[this.currentStep];
document.getElementById('activity-instruction').textContent = step.instruction;
this.setFeedback("", "black");
},

advanceStep() {
if (this.isChecking) return;
this.isChecking = true;
this.setFeedback("Correct!", "green");
this.currentStep++;
setTimeout(() => {
    this.isChecking = false;
    this.updateStep();
}, 1000);
},

completeActivity() {
document.getElementById('activity-instruction').textContent = "Module Complete!";
document.getElementById('activity-progress').style.width = `100%`;
this.setFeedback("Excellent work!", "green");
renderer.domElement.removeEventListener('click', this.onCanvasClick, false);
},

setFeedback(text, color) {
const feedbackEl = document.getElementById('activity-feedback');
feedbackEl.textContent = text;
feedbackEl.style.color = color;
},

onCanvasClick: (event) => {
    if (LearningModule.isChecking || !LearningModule.currentActivity || LearningModule.currentActivity.title !== 'Anatomy Scavenger Hunt') return;
    const step = LearningModule.currentActivity.steps[LearningModule.currentStep];
    if (!step) return;
    const mouse = new THREE.Vector2();
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    let found = false;
    if (intersects.length > 0) {
        for (const intersect of intersects) {
            let clickedObject = intersect.object;
            while (clickedObject) {
                const labeledInfo = labeledObjects.find(item => item.object === clickedObject);
                if (labeledInfo && labeledInfo.name === step.target) {
                    LearningModule.advanceStep();
                    found = true;
                    break; 
                }
                clickedObject = clickedObject.parent;
            }
            if (found) break;
        }
    }
    if (!found) LearningModule.setFeedback("Not quite. Keep looking!", "crimson");
},

checkCoordinateSuccess(axis, positive) {
if (this.isChecking || !this.currentActivity || this.currentActivity.title !== 'Machine Coordinates') return;
const step = this.currentActivity.steps[this.currentStep];
if (step && step.target.axis === axis && step.target.direction === positive) {
this.clicksDone++;
const instructionEl = document.getElementById('activity-instruction');
instructionEl.textContent = `${step.instruction.split('(')[0]} (${this.clicksDone}/${step.target.clicksRequired})`;
if (this.clicksDone >= step.target.clicksRequired) {
    this.advanceStep();
}
}
},

checkAlignmentSuccess() {
if (!this.currentActivity || this.currentActivity.title !== 'Basic Patient Alignment') return;
const dist = tumor.getWorldPosition(new THREE.Vector3()).distanceTo(laserIsocenter);
if (dist < ALIGNMENT_TOLERANCE) {
    this.advanceStep();
}
},

checkParameterSuccess() {
    if (this.isChecking || !this.currentActivity) return;
    const step = this.currentActivity.steps[this.currentStep];
    if (!step.target || !step.target.parameter) return;

    let currentValue;
    const target = step.target;

    switch(target.parameter) {
        case 'couchLat':
            currentValue = couchTopGroup.position.x * 100;
            if (Math.abs(currentValue - target.value) <= target.tolerance) this.advanceStep();
            break;
        case 'couchLng':
            currentValue = couchTopGroup.position.z * 100;
            if (Math.abs(currentValue - target.value) <= target.tolerance) this.advanceStep();
            break;
        case 'couchVrt':
            currentValue = (couchGroup.position.y - initialCouchY) * 100;
            if (Math.abs(currentValue - target.value) <= target.tolerance) this.advanceStep();
            break;
        case 'gantry':
            let gantryAngle = -(gantryRotatingAssembly.rotation.z * 180 / Math.PI);
            currentValue = (gantryAngle % 360 + 360) % 360;
            if (Math.abs(currentValue - target.value) <= target.tolerance) this.advanceStep();
            break;
        case 'fieldSize':
            const currentFSX = jawPositions.x1 + jawPositions.x2;
            const currentFSY = jawPositions.y1 + jawPositions.y2;
            const x_ok = Math.abs(currentFSX - target.valueX) <= target.tolerance;
            const y_ok = Math.abs(currentFSY - target.valueY) <= target.tolerance;
            if (x_ok && y_ok) this.advanceStep();
            break;
    }
}
};
window.LearningModule = LearningModule; // Expose to global scope

// ===== Init =====
init();
animate();

function init() {
scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);
camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 120);
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);
controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.maxPolarAngle = Math.PI / 2;
scene.add(new THREE.AmbientLight(0x808080));
const dir = new THREE.DirectionalLight(0xffffff, 0.7);
dir.position.set(15, 20, 15);
dir.castShadow = true; dir.shadow.mapSize.set(2048,2048); scene.add(dir);
const groundPlane = new THREE.Mesh( new THREE.PlaneGeometry(40, 40), new THREE.MeshStandardMaterial({ color: 0xe0e0e0, side: THREE.DoubleSide }) );
groundPlane.rotation.x = -Math.PI / 2;
groundPlane.position.y = groundY;
groundPlane.receiveShadow = true;
scene.add(groundPlane);
buildGantry();
buildCouch();
buildPatient();
buildLasers();
updateIsocenterOffset();
camera.position.set(8, isocenterYTarget + 3, machineIsocenter.z + 9);
camera.lookAt(0, isocenterYTarget, machineIsocenter.z);
controls.target.set(0, isocenterYTarget, machineIsocenter.z);
controls.update();
hookLabels();
setupUI();
window.addEventListener('resize', onWindowResize);
newCase();
}

function buildGantry() {
const gantrySetupGroup = new THREE.Group();
gantrySetupGroup.position.set(0, 0, gantryPlaneZTarget);
scene.add(gantrySetupGroup);
const drivestandHeight = isocenterYTarget + 0.3;
const drivestandDepth = 0.8;
drivestand = new THREE.Mesh(new THREE.BoxGeometry(0.8, drivestandHeight, drivestandDepth), drivestandMaterial);
const visualGap = 0.4;
drivestand.position.set(0, (drivestandHeight / 2) + groundY, -(visualGap + drivestandDepth / 2));
gantrySetupGroup.add(drivestand);
enableShadows(drivestand);
connectingArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, visualGap), lightGrayMat);
connectingArm.position.set(0, isocenterYTarget, -visualGap / 2);
gantrySetupGroup.add(connectingArm);
enableShadows(connectingArm);
gantryRotatingAssembly = new THREE.Group();
gantryRotatingAssembly.position.set(0, isocenterYTarget, 0);
gantrySetupGroup.add(gantryRotatingAssembly);
enableShadows(gantryRotatingAssembly);
window.gantryRotatingAssembly = gantryRotatingAssembly;
verticalArmL = new THREE.Mesh(new THREE.BoxGeometry(verticalArmLSize, newVerticalArmTotalLength, verticalArmLSize), lightBlueMat);
gantryRotatingAssembly.add(verticalArmL);
acceleratorHousing = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, acceleratorHousingLength), lightBlueMat);
acceleratorHousing.position.set(0, newVerticalArmTotalLength / 2, acceleratorHousingLength / 2);
gantryRotatingAssembly.add(acceleratorHousing);
head = new THREE.Mesh(new THREE.BoxGeometry(headSize, headSize, headSize), transparentLightGrayMat);
head.position.set(0, newVerticalArmTotalLength / 2, acceleratorHousingLength);
gantryRotatingAssembly.add(head);
head.updateWorldMatrix(true, false);
machineIsocenter = head.getWorldPosition(new THREE.Vector3());
machineIsocenter.y -= newVerticalArmTotalLength / 2;
const jawsGroup = new THREE.Group();
head.add(jawsGroup);
const jawThickness = 0.06;
const jawDepth = 0.3;
jawX1 = new THREE.Mesh(new THREE.BoxGeometry(jawThickness, headSize, jawDepth), brightOrangeMat);
jawX2 = new THREE.Mesh(new THREE.BoxGeometry(jawThickness, headSize, jawDepth), brightOrangeMat);
jawY1 = new THREE.Mesh(new THREE.BoxGeometry(headSize, jawThickness, jawDepth), brightCyanMat);
jawY2 = new THREE.Mesh(new THREE.BoxGeometry(headSize, jawThickness, jawDepth), brightCyanMat);
jawsGroup.add(jawX1, jawX2, jawY1, jawY2);
updateJawVisuals();
detectorArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), lightGrayMat);
detectorPanel = new THREE.Mesh(new THREE.BoxGeometry(detectorPanelWidth, detectorPanelHeight, detectorPanelThickness), lightGrayMat);
gantryRotatingAssembly.add(detectorArm, detectorPanel);
setDetectorState(false);
const gunLength = 0.3, gunRadius = 0.15;
electronGun = new THREE.Mesh(new THREE.CylinderGeometry(gunRadius, gunRadius * 0.8, gunLength, 16), metallicGrayMat);
electronGun.rotation.x = Math.PI / 2;
electronGun.position.set(0, 0, -acceleratorHousingLength / 2 - gunLength / 2);
acceleratorHousing.add(electronGun);
enableShadows(electronGun);
const waveguideRadius = 0.05;
const waveguideLength = acceleratorHousingLength - gunLength - 0.1;
waveguide = new THREE.Mesh(new THREE.CylinderGeometry(waveguideRadius, waveguideRadius, waveguideLength, 16), metallicGrayMat);
waveguide.rotation.x = Math.PI / 2;
waveguide.position.set(0, 0, electronGun.position.z + gunLength / 2 + waveguideLength / 2);
acceleratorHousing.add(waveguide);
enableShadows(waveguide);
const targetRadius = 0.08, targetThickness = 0.02;
target = new THREE.Mesh(new THREE.CylinderGeometry(targetRadius, targetRadius, targetThickness, 16), targetMat);
target.rotation.x = Math.PI / 2;
target.position.set(0, 0, 0.1);
head.add(target);
enableShadows(target);
const shortArmGeo = new THREE.BoxGeometry(0.15, 0.2, 0.15);
sideDetectorShortArm = new THREE.Mesh(shortArmGeo, mediumGrayMat);
kvTubeShortArm = new THREE.Mesh(shortArmGeo, mediumGrayMat);
const kvOffset = 0.45;
sideDetectorShortArm.position.set(-(verticalArmLSize / 2 + kvOffset), 0, 0);
kvTubeShortArm.position.set(verticalArmLSize / 2 + kvOffset, 0, 0);
gantryRotatingAssembly.add(sideDetectorShortArm, kvTubeShortArm);
sideDetectorPanel = new THREE.Mesh(new THREE.BoxGeometry(detectorPanelWidth, detectorPanelHeight, detectorPanelThickness), lightGrayMat);
sideDetectorArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), lightGrayMat);
gantryRotatingAssembly.add(sideDetectorPanel, sideDetectorArm);
kvTubeGroup = new THREE.Group();
kvTubeHousing = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.5, 20), metallicGrayMat);
kvTubeHead = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.1, 20), mediumGrayMat);
kvTubeHead.position.y = 0.25;
kvTubeGroup.add(kvTubeHousing, kvTubeHead);
kvTubeArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), lightGrayMat);
gantryRotatingAssembly.add(kvTubeGroup, kvTubeArm);
setSideDetectorState(false);
const coneMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, transparent: true, opacity: 0.6 });
const coneHeight = 0.8;
const coneSize = headSize * 0.7;
electronCone = new THREE.Mesh(new THREE.BoxGeometry(coneSize, coneHeight, coneSize), coneMaterial);
electronCone.position.set(0, -(headSize / 2) - (coneHeight / 2), 0);
head.add(electronCone);
electronCone.visible = false;
const klystronHeight = 0.6;
klystron = new THREE.Mesh(new THREE.BoxGeometry(0.4, klystronHeight, 0.4), klystronMat);
klystron.position.set(drivestand.position.x, (drivestand.position.y - drivestandHeight / 2) + klystronHeight / 2, drivestand.position.z);
gantrySetupGroup.add(klystron);
enableShadows(klystron);
const klystronWaveguideRadius = 0.04;
const wgStatic_Y_Start = klystron.position.y + klystronHeight / 2;
const wgStatic_Y_End = connectingArm.position.y;
const wgStatic_Vert_Length = Math.abs(wgStatic_Y_End - wgStatic_Y_Start);
wgStaticVert = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgStatic_Vert_Length > 0 ? wgStatic_Vert_Length : 0.01, 16), klystronWaveguideMat);
wgStaticVert.position.set(klystron.position.x, wgStatic_Y_Start + wgStatic_Vert_Length / 2, klystron.position.z);
gantrySetupGroup.add(wgStaticVert);
const wgStatic_Z_Start = klystron.position.z;
const wgStatic_Z_End = connectingArm.position.z + visualGap / 2;
const wgStatic_Horiz_Length = Math.abs(wgStatic_Z_End - wgStatic_Z_Start);
wgStaticHoriz = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgStatic_Horiz_Length > 0 ? wgStatic_Horiz_Length : 0.01, 16), klystronWaveguideMat);
wgStaticHoriz.rotation.x = Math.PI / 2;
wgStaticHoriz.position.set(klystron.position.x, wgStatic_Y_End, wgStatic_Z_Start + (wgStatic_Z_End - wgStatic_Z_Start) / 2);
gantrySetupGroup.add(wgStaticHoriz);
const eg_local_y = newVerticalArmTotalLength / 2;
const wgRotating_Vert_Length = eg_local_y;
wgRotatingVert = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgRotating_Vert_Length > 0 ? wgRotating_Vert_Length : 0.01, 16), klystronWaveguideMat);
wgRotatingVert.position.set(0, wgRotating_Vert_Length / 2, 0);
gantryRotatingAssembly.add(wgRotatingVert);
const electronGunWorldPos = new THREE.Vector3();
acceleratorHousing.updateMatrixWorld(true);
electronGun.getWorldPosition(electronGunWorldPos);
const electronGunLocalPosGRA = gantryRotatingAssembly.worldToLocal(electronGunWorldPos.clone());
const wgRotating_Horiz_Z_Start = 0;
const wgRotating_Horiz_Z_End = electronGunLocalPosGRA.z;
const wgRotating_Horiz_Length_Actual = Math.abs(wgRotating_Horiz_Z_End - wgRotating_Horiz_Z_Start);
wgRotatingHoriz = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgRotating_Horiz_Length_Actual > 0 ? wgRotating_Horiz_Length_Actual : 0.01, 16), klystronWaveguideMat);
wgRotatingHoriz.rotation.x = Math.PI / 2;
wgRotatingHoriz.position.set(0, eg_local_y, (wgRotating_Horiz_Z_Start + wgRotating_Horiz_Z_End) / 2);
gantryRotatingAssembly.add(wgRotatingHoriz);
}

function buildCouch() { couchGroup = new THREE.Group(); window.couchGroup = couchGroup; initialCouchY = (couchBaseHeight/2) + groundY; couchGroup.position.set(0, initialCouchY, gantryPlaneZTarget + couchSeparationOffset); scene.add(couchGroup); enableShadows(couchGroup); couchSupportBase = new THREE.Mesh(new THREE.BoxGeometry(couchWidth * 0.8, couchBaseHeight, couchLength * 0.5), lightBeigeMat); couchSupportBase.position.y = 0; couchGroup.add(couchSupportBase); couchTopGroup = new THREE.Group(); window.couchTopGroup = couchTopGroup; couchTopGroup.position.y = (couchBaseHeight/2) + (couchPlatformHeight/2); couchTopGroup.position.z = 0; couchGroup.add(couchTopGroup); couchPlatform = new THREE.Mesh(new THREE.BoxGeometry(couchWidth, couchPlatformHeight, couchLength), mediumGrayMat); couchTopGroup.add(couchPlatform); couchAccordion = new THREE.Group(); couchAccordion.position.set(couchGroup.position.x, groundY, couchGroup.position.z); scene.add(couchAccordion); enableShadows(couchAccordion); couchAccordionVisual = new THREE.Mesh(new THREE.BoxGeometry(couchWidth * 0.7, accordionGeometricHeight, couchLength * 0.4), darkGrayMatMaterial); couchAccordionVisual.position.y = accordionGeometricHeight/2; couchAccordion.add(couchAccordionVisual); updateAccordion(); }
function buildPatient() { patientModel = new THREE.Group(); couchTopGroup.add(patientModel); const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.26, 0.75, 20), patientMat); torso.castShadow = true; patientModel.add(torso); const neck  = new THREE.Mesh(new THREE.CylinderGeometry(0.10, 0.10, 0.12, 16), patientMat); neck.position.set(0, 0.75/2 + 0.08, 0); patientModel.add(neck); const headS = new THREE.Mesh(new THREE.SphereGeometry(0.14, 20, 20), patientMat); headS.position.set(0, neck.position.y + 0.12, 0); headS.scale.set(0.8, 1, 1); patientModel.add(headS); const armGeo = new THREE.CylinderGeometry(0.07, 0.06, 0.70, 12); const leftArm = new THREE.Mesh(armGeo, patientMat); leftArm.position.set(-0.32, 0.0, 0); patientModel.add(leftArm); const rightArm= new THREE.Mesh(armGeo, patientMat); rightArm.position.set( 0.32, 0.0, 0); patientModel.add(rightArm); const legGeo = new THREE.CylinderGeometry(0.12, 0.09, 0.85, 12); const leftLeg = new THREE.Mesh(legGeo, patientMat); leftLeg.position.set(-0.12, -0.85, 0); patientModel.add(leftLeg); const rightLeg= new THREE.Mesh(legGeo, patientMat); rightLeg.position.set( 0.12, -0.85, 0); patientModel.add(rightLeg); tumor = new THREE.Mesh(new THREE.SphereGeometry(0.05, 24, 24), tumorMat); tumor.renderOrder = 2; patientModel.add(tumor); const tatGeo = new THREE.SphereGeometry(0.012, 12, 12); tattooAnterior = new THREE.Mesh(tatGeo, tattooMat); tattooLeft = new THREE.Mesh(tatGeo, tattooMat); tattooRight = new THREE.Mesh(tatGeo, tattooMat); [tattooAnterior, tattooLeft, tattooRight].forEach(t => { t.renderOrder = 3; patientModel.add(t); }); patientModel.rotation.x = -Math.PI/2; const patientOnCouchY = (couchPlatformHeight / 2) + 0.28 + 0.01; patientModel.position.set(0, patientOnCouchY, -0.3); }
function buildLasers() { const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false, transparent: true, opacity: 0.95 }); const laserLen = 30, laserRadius = 0.01; const geo = new THREE.CylinderGeometry(laserRadius, laserRadius, laserLen, 8); laserX = new THREE.Mesh(geo, laserMaterial); laserX.rotation.z = Math.PI/2; scene.add(laserX); laserY = new THREE.Mesh(geo, laserMaterial); scene.add(laserY); laserZ = new THREE.Mesh(geo, laserMaterial); laserZ.rotation.x = Math.PI/2; scene.add(laserZ); [laserX, laserY, laserZ].forEach(l => { l.renderOrder = 10; }); }
function hookLabels() { const ids = ['drivestand','connectingArm','acceleratorHousing','verticalArmL','head','couchBase','couchTop','couchAccordion','detectorPanel','sideDetectorPanel','kvTube','electronCone','axisX','axisY','axisZ','electronGun','waveguide','target','klystron','klystronWaveguide']; ids.forEach(id => labels[id] = document.getElementById('label-'+id)); const xAxisLabelObj = new THREE.Object3D(); xAxisLabelObj.position.set(3.2,0,0); scene.add(xAxisLabelObj); const yAxisLabelObj = new THREE.Object3D(); yAxisLabelObj.position.set(0,3.2,0); scene.add(yAxisLabelObj); const zAxisLabelObj = new THREE.Object3D(); zAxisLabelObj.position.set(0,0,3.2); scene.add(zAxisLabelObj); labeledObjects.push({ object: drivestand, label: labels.drivestand, name: 'Drivestand' }); labeledObjects.push({ object: connectingArm, label: labels.connectingArm, name: 'Connecting Arm' }); labeledObjects.push({ object: acceleratorHousing, label: labels.acceleratorHousing, name: 'Accelerator Housing' }); labeledObjects.push({ object: verticalArmL, label: labels.verticalArmL, name: 'Vertical Arm' }); labeledObjects.push({ object: head, label: labels.head, name: 'Head' }); labeledObjects.push({ object: couchSupportBase, label: labels.couchBase, name: 'Couch Base' }); labeledObjects.push({ object: couchPlatform, label: labels.couchTop, name: 'Couch Top' }); labeledObjects.push({ object: couchAccordionVisual, label: labels.couchAccordion, name: 'Accordion' }); labeledObjects.push({ object: detectorPanel, label: labels.detectorPanel, name: 'MV Detector Panel' }); labeledObjects.push({ object: sideDetectorPanel, label: labels.sideDetectorPanel, name: 'kV Detector Panel' }); labeledObjects.push({ object: kvTubeHousing, label: labels.kvTube, name: 'kV X-Ray Tube' }); labeledObjects.push({ object: electronCone, label: labels.electronCone, name: 'Electron Cone' }); labeledObjects.push({ object: xAxisLabelObj, label: labels.axisX, name: 'X-Axis' }); labeledObjects.push({ object: yAxisLabelObj, label: labels.axisY, name: 'Y-Axis' }); labeledObjects.push({ object: zAxisLabelObj, label: labels.axisZ, name: 'Z-Axis' }); labeledObjects.push({ object: electronGun, label: labels.electronGun, name: 'Electron Gun' }); labeledObjects.push({ object: waveguide, label: labels.waveguide, name: 'Waveguide (Acc.)' }); labeledObjects.push({ object: target, label: labels.target, name: 'Target' }); labeledObjects.push({ object: klystron, label: labels.klystron, name: 'Klystron' }); labeledObjects.push({ object: wgStaticHoriz, label: labels.klystronWaveguide, name: 'Waveguide (Klystron)' }); updateAllLabelVisibility(); }
function newCase() { tumorLocalOffset.set((Math.random()-0.5)*0.12, (Math.random()-0.2)*0.40, (Math.random()-0.5)*0.12); tumor.position.copy(tumorLocalOffset); const torsoParams = { height: 0.75, radiusTop: 0.28, radiusBottom: 0.26 }; const y_norm = (tumorLocalOffset.y + torsoParams.height/2) / torsoParams.height; const radiusAtY = torsoParams.radiusBottom + (torsoParams.radiusTop - torsoParams.radiusBottom) * y_norm; tattooAnterior.position.set(tumorLocalOffset.x, tumorLocalOffset.y, radiusAtY); tattooLeft.position.set(-radiusAtY, tumorLocalOffset.y, tumorLocalOffset.z); tattooRight.position.set(radiusAtY, tumorLocalOffset.y, tumorLocalOffset.z); couchTopGroup.position.x = (Math.random()-0.5) * 0.20; couchTopGroup.position.z = (Math.random()-0.5) * 0.30; couchGroup.position.y    = (couchBaseHeight/2) + groundY + 0.20 + Math.random()*0.20; constrainCouch(); updateReadouts(); alignmentMessageElement.style.color = '#333'; alignmentMessageElement.textContent = 'Use couch/nudge controls to bring tattoos to laser lines.'; LearningModule.checkAlignmentSuccess(); }
function nudgePatient(dx, dy, dz) { couchTopGroup.position.x += dx * MOVE_STEP; couchGroup.position.y    += dy * MOVE_STEP; couchTopGroup.position.z += dz * MOVE_STEP; constrainCouch(); updateReadouts(); }
function centerCouch() { couchTopGroup.position.x = 0; couchTopGroup.position.z = 0; const patientSurfaceWorldY = new THREE.Vector3(); tattooAnterior.getWorldPosition(patientSurfaceWorldY); const requiredShiftY = laserIsocenter.y - patientSurfaceWorldY.y; couchGroup.position.y += requiredShiftY; constrainCouch(); updateReadouts(); }
function checkAlignment() { const tumorWorld = new THREE.Vector3(); tumor.getWorldPosition(tumorWorld); const dist = tumorWorld.distanceTo(laserIsocenter); const shift = new THREE.Vector3().subVectors(laserIsocenter, tumorWorld); const isAligned = dist < ALIGNMENT_TOLERANCE; const msg = isAligned ? `Alignment OK! Tumor at laser isocenter within ${(dist*1000).toFixed(1)} mm.` : `Tumor is ${(dist*100).toFixed(1)} cm from laser ISO. Required Shifts → X: ${(shift.x*100).toFixed(1)} cm, Y: ${(shift.y*100).toFixed(1)} cm, Z: ${(shift.z*100).toFixed(1)} cm`; alignmentMessageElement.innerHTML = msg; alignmentMessageElement.style.color = isAligned ? 'green' : 'crimson'; if (isAligned) { LearningModule.checkAlignmentSuccess(); } }
function updateIsocenterOffset() { const x = parseFloat(document.getElementById('isoOffsetX').value) / 100; const y = parseFloat(document.getElementById('isoOffsetY').value) / 100; const z = parseFloat(document.getElementById('isoOffsetZ').value) / 100; isocenterOffset.set(x || 0, y || 0, z || 0); laserIsocenter.copy(machineIsocenter).add(isocenterOffset); laserX.position.copy(laserIsocenter); laserY.position.copy(laserIsocenter); laserZ.position.copy(laserIsocenter); }

// ===== LINAC Interactions =====
function toggleLabels(forceState) {
labelsVisible = (forceState !== undefined) ? forceState : !labelsVisible;
if (!labelsVisible) hideAllLabels();
else updateAllLabelVisibility();
};

function rotateGantry(clockwise = true, stepInDegrees = 5.0) {
    const direction = clockwise ? -1 : 1;
    const stepInRadians = THREE.MathUtils.degToRad(stepInDegrees);
    gantryRotatingAssembly.rotation.z += direction * stepInRadians;
    updateReadouts();
    LearningModule.checkParameterSuccess();
};

function moveSelectedJaw(direction) {
    const activeJaw = document.querySelector('input[name="active_jaw"]:checked').value;
    const step = parseFloat(document.querySelector('input[name="jaw_step"]:checked').value);
    const maxJawPos = (headSize / 2) * 100 * 0.9;
    
    jawPositions[activeJaw] += direction * step;

    // Constrain jaws to be positive and within physical limits
    jawPositions[activeJaw] = THREE.MathUtils.clamp(jawPositions[activeJaw], 0, maxJawPos);

    updateJawVisuals();
    updateReadouts();
    LearningModule.checkParameterSuccess();
}

function updateJawVisuals() {
    // Convert public-facing absolute cm values to internal signed meter values for positioning
    const x1_m = -jawPositions.x1 / 100;
    const x2_m = jawPositions.x2 / 100;
    const y1_m = jawPositions.y1 / 100;
    const y2_m = -jawPositions.y2 / 100;

    jawX1.position.x = x1_m;
    jawX2.position.x = x2_m;
    jawY1.position.y = y1_m;
    jawY2.position.y = y2_m;

    const fsX_m = x2_m - x1_m;
    jawY1.geometry.dispose();
    jawY1.geometry = new THREE.BoxGeometry(fsX_m, jawY1.geometry.parameters.height, jawY1.geometry.parameters.depth);
    jawY2.geometry.dispose();
    jawY2.geometry = new THREE.BoxGeometry(fsX_m, jawY2.geometry.parameters.height, jawY2.geometry.parameters.depth);
    jawY1.position.x = x1_m + fsX_m / 2;
    jawY2.position.x = x1_m + fsX_m / 2;

    const fsY_m = y1_m - y2_m;
    jawX1.geometry.dispose();
    jawX1.geometry = new THREE.BoxGeometry(jawX1.geometry.parameters.width, fsY_m, jawX1.geometry.parameters.depth);
    jawX2.geometry.dispose();
    jawX2.geometry = new THREE.BoxGeometry(jawX2.geometry.parameters.width, fsY_m, jawX2.geometry.parameters.depth);
    jawX1.position.y = y2_m + fsY_m / 2;
    jawX2.position.y = y2_m + fsY_m / 2;
}

function moveCouch(up = true) {
    const stepCm = parseFloat(document.querySelector('input[name="couch_step"]:checked').value);
    const stepM = stepCm / 100;
    const dir = up ? 1 : -1;
    couchGroup.position.y += dir * stepM;
    constrainCouch();
    updateReadouts();
    LearningModule.checkCoordinateSuccess('Y', up);
    LearningModule.checkParameterSuccess();
};

function moveCouchLongitudinal(towardsGantry = true) {
    const stepCm = parseFloat(document.querySelector('input[name="couch_step"]:checked').value);
    const stepM = stepCm / 100;
    const dir = towardsGantry ? -1 : 1;
    couchTopGroup.position.z += dir * stepM;
    constrainCouch();
    updateReadouts();
    LearningModule.checkCoordinateSuccess('Z', towardsGantry);
    LearningModule.checkParameterSuccess();
};

function moveCouchLateral(positive = true) {
    const stepCm = parseFloat(document.querySelector('input[name="couch_step"]:checked').value);
    const stepM = stepCm / 100;
    const dir = positive ? 1 : -1;
    couchTopGroup.position.x += dir * stepM;
    constrainCouch();
    updateReadouts();
    LearningModule.checkCoordinateSuccess('X', positive);
    LearningModule.checkParameterSuccess();
};

function toggleDetector() { setDetectorState(!detectorExtended); }
function setDetectorState(isExtended) { detectorExtended = isExtended; if (isExtended) { const isoLocal = gantryRotatingAssembly.worldToLocal(machineIsocenter.clone()); const armStartPos = new THREE.Vector3(0, -newVerticalArmTotalLength / 2, 0); const panelPos = new THREE.Vector3(0, armStartPos.y, isoLocal.z); const armVector = new THREE.Vector3().subVectors(panelPos, armStartPos); const armLength = armVector.length(); detectorArm.visible = true; detectorPanel.visible = true; detectorArm.geometry.dispose(); detectorArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, armLength, 16); detectorArm.position.copy(armStartPos).add(armVector.clone().multiplyScalar(0.5)); detectorArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), armVector.clone().normalize()); detectorPanel.position.copy(panelPos); const headWorldPos = head.getWorldPosition(new THREE.Vector3()); const gantryRight = new THREE.Vector3(1, 0, 0).applyQuaternion(gantryRotatingAssembly.quaternion); detectorPanel.up.copy(gantryRight); detectorPanel.lookAt(headWorldPos); } else { detectorArm.visible = false; detectorPanel.visible = true; detectorPanel.rotation.set(0, 0, 0); detectorPanel.position.set(0, -newVerticalArmTotalLength / 2, verticalArmLSize / 2 + detectorPanelThickness / 2); } document.getElementById('detectorToggleButton').textContent = detectorExtended ? 'Retract MV Imager' : 'Extend MV Imager'; }
function toggleSideDetector() { setSideDetectorState(!sideDetectorExtended); }
function setSideDetectorState(isExtended) { sideDetectorExtended = isExtended; const allImagerParts = [sideDetectorPanel, sideDetectorArm, kvTubeGroup, kvTubeArm]; if (isExtended) { allImagerParts.forEach(p => p.visible = true); const isoLocal = gantryRotatingAssembly.worldToLocal(machineIsocenter.clone()); const detectorStartPos = sideDetectorShortArm.position.clone(); const detectorEndPos = new THREE.Vector3(detectorStartPos.x, detectorStartPos.y, isoLocal.z); const detectorVector = new THREE.Vector3().subVectors(detectorEndPos, detectorStartPos); const detectorArmLength = detectorVector.length(); sideDetectorArm.geometry.dispose(); sideDetectorArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, detectorArmLength, 16); sideDetectorArm.position.copy(detectorStartPos).add(detectorVector.clone().multiplyScalar(0.5)); sideDetectorArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), detectorVector.clone().normalize()); sideDetectorPanel.position.copy(detectorEndPos); sideDetectorPanel.rotation.set(0, Math.PI / 2, 0); const tubeStartPos = kvTubeShortArm.position.clone(); const tubeEndPos = new THREE.Vector3(tubeStartPos.x, tubeStartPos.y, isoLocal.z); const tubeVector = new THREE.Vector3().subVectors(tubeEndPos, tubeStartPos); const tubeArmLength = tubeVector.length(); kvTubeArm.geometry.dispose(); kvTubeArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, tubeArmLength, 16); kvTubeArm.position.copy(tubeStartPos).add(tubeVector.clone().multiplyScalar(0.5)); kvTubeArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tubeVector.clone().normalize()); kvTubeGroup.position.copy(tubeEndPos); kvTubeGroup.rotation.set(Math.PI / 2, Math.PI, 0); } else { allImagerParts.forEach(p => p.visible = false); } document.getElementById('sideDetectorToggleButton').textContent = detectorExtended ? 'Retract kV Imagers' : 'Extend kV Imagers'; }
function toggleElectronCone() { isConeAttached = !isConeAttached; electronCone.visible = isConeAttached; document.getElementById('coneToggleButton').textContent = isConeAttached ? 'Remove Electron Cone' : 'Attach Electron Cone'; };

// ===== UI and Readouts =====
function setupUI() {
readoutGantry = document.getElementById('readout-gantry');
readoutJawsX = document.getElementById('readout-jawsX');
readoutJawsY = document.getElementById('readout-jawsY');
readoutCouchX = document.getElementById('readout-couchX');
readoutCouchY = document.getElementById('readout-couchY');
readoutCouchZ = document.getElementById('readout-couchZ');
const toggleButton = document.getElementById('console-toggle-button');
const consoleWindow = document.getElementById('console-window');
const leftPanel = document.getElementById('left-panel-container');
let panelsVisible = true;
toggleButton.addEventListener('click', () => {
panelsVisible = !panelsVisible;
consoleWindow.classList.toggle('hidden', !panelsVisible);
leftPanel.classList.toggle('hidden', !panelsVisible);
toggleButton.innerHTML = panelsVisible ? '«' : '»';
toggleButton.style.right = panelsVisible ? '360px' : '20px';
});
updateReadouts();
}

function updateReadouts() {
let gantryAngle = -(gantryRotatingAssembly.rotation.z * 180 / Math.PI);
gantryAngle = (gantryAngle % 360 + 360) % 360;
readoutGantry.textContent = `${gantryAngle.toFixed(1)}°`;

readoutJawsX.textContent = `${jawPositions.x1.toFixed(1)} / ${jawPositions.x2.toFixed(1)} cm`;
readoutJawsY.textContent = `${jawPositions.y1.toFixed(1)} / ${jawPositions.y2.toFixed(1)} cm`;

const couchVrt = ((couchGroup.position.y - initialCouchY) * 100).toFixed(1);
const couchLng = (couchTopGroup.position.z * 100).toFixed(1);
const couchLat = (couchTopGroup.position.x * 100).toFixed(1);
readoutCouchY.textContent = `${couchVrt} cm`;
readoutCouchZ.textContent = `${couchLng} cm`;
readoutCouchX.textContent = `${couchLat} cm`;
}

function constrainCouch(){ const minY = (couchBaseHeight/2) + groundY; const maxY = isocenterYTarget + 0.5; couchGroup.position.y = THREE.MathUtils.clamp(couchGroup.position.y, minY, maxY); const zExt = couchLength * 0.4; const xExt = couchWidth * 0.4; couchTopGroup.position.z = THREE.MathUtils.clamp(couchTopGroup.position.z, -zExt, zExt); couchTopGroup.position.x = THREE.MathUtils.clamp(couchTopGroup.position.x, -xExt, xExt); updateAccordion(); }
function enableShadows(o){ o.castShadow = true; o.receiveShadow = true; if (o.children) o.children.forEach(enableShadows); }
function updateAccordion(){ const baseBottomWorldY = couchGroup.position.y - (couchBaseHeight/2); const h = Math.max(0.01, baseBottomWorldY - groundY); couchAccordionVisual.scale.y = h / accordionGeometricHeight; couchAccordionVisual.position.y = h/2; couchAccordion.position.x = couchGroup.position.x; couchAccordion.position.z = couchGroup.position.z; }
function updateAllLabelVisibility(){ labeledObjects.forEach(({object,label})=>updateLabelPosition(label, object)); }
function hideAllLabels(){ labeledObjects.forEach(({label})=>{ if(label) label.style.visibility='hidden'; }); }
function updateLabelPosition(labelElement, object3D){ if(!labelElement || !object3D) return; if (!labelsVisible || !object3D.visible){ labelElement.style.visibility='hidden'; return; } const tempV = new THREE.Vector3(); scene.updateMatrixWorld(true); object3D.getWorldPosition(tempV); tempV.project(camera); const x = (tempV.x * .5 + .5) * renderer.domElement.clientWidth; const y = (tempV.y * -.5 + .5) * renderer.domElement.clientHeight; const objectWorldPosition = new THREE.Vector3(); object3D.getWorldPosition(objectWorldPosition); const cameraDirection = new THREE.Vector3(); camera.getWorldDirection(cameraDirection); const objectDirection = new THREE.Vector3().subVectors(objectWorldPosition, camera.position); if (objectDirection.dot(cameraDirection) > 0 && tempV.z < 1 && tempV.z > -1){ labelElement.style.transform = `translate(-50%, -110%) translate(${x}px,${y}px)`; labelElement.style.visibility = 'visible'; } else { labelElement.style.visibility = 'hidden'; } }
function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); updateAllLabelVisibility(); }
function animate(){ requestAnimationFrame(animate); controls.update(); if (labelsVisible) updateAllLabelVisibility(); renderer.render(scene, camera); }
function makeDraggable(element){ let pos1=0,pos2=0,pos3=0,pos4=0; const header=element.querySelector(".ui-header")||element; header.onmousedown=dragMouseDown; function dragMouseDown(e){ e=e||window.event; e.preventDefault(); pos3=e.clientX; pos4=e.clientY; document.onmouseup=closeDragElement; document.onmousemove=elementDrag; } function elementDrag(e){ e=e||window.event; e.preventDefault(); pos1=pos3-e.clientX; pos2=pos4-e.clientY; pos3=e.clientX; pos4=e.clientY; element.style.top=(element.offsetTop - pos2)+"px"; element.style.left=(element.offsetLeft - pos1)+"px"; } function closeDragElement(){ document.onmouseup=null; document.onmousemove=null; } }
window.rotateGantry = rotateGantry; window.moveSelectedJaw = moveSelectedJaw; window.moveCouch = moveCouch; window.moveCouchLongitudinal = moveCouchLongitudinal; window.moveCouchLateral = moveCouchLateral; window.toggleDetector = toggleDetector;
window.toggleSideDetector = toggleSideDetector; window.toggleElectronCone = toggleElectronCone; window.toggleLabels = toggleLabels; window.newCase = newCase; window.nudgePatient = nudgePatient; window.centerCouch = centerCouch;
window.checkAlignment = checkAlignment; window.updateIsocenterOffset = updateIsocenterOffset;
window.openTab = (evt, tabName) => { let i, tabcontent, tablinks; tabcontent = document.getElementsByClassName("tab-content"); for (i = 0; i < tabcontent.length; i++) { tabcontent[i].style.display = "none"; } tablinks = document.getElementsByClassName("tab-button"); for (i = 0; i < tablinks.length; i++) { tablinks[i].className = tablinks[i].className.replace(" active", ""); } document.getElementById(tabName).style.display = "block"; evt.currentTarget.className += " active"; };
</script>
</body>
</html>
