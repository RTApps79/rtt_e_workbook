<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>4D CT Simulator with Tutorials</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
        }

        canvas {
            display: block;
        }

        .controls-sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 220px;
            height: 100%;
            background-color: #ffffff;
            padding: 15px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 10;
        }

        .sidebar-title {
            font-weight: bold;
            margin-top: 15px;
            margin-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
            color: #333;
        }

        .button-group {
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
        }

            .button-group span {
                font-size: 0.9em;
                margin-bottom: 5px;
                width: 100%;
                text-align: center;
            }

            .button-group button {
                flex-basis: 48%;
                margin: 2px 0;
                padding: 5px;
                border: 1px solid #ccc;
                background-color: #f8f9fa;
                border-radius: 4px;
                cursor: pointer;
            }

                .button-group button:hover {
                    background-color: #e2e6ea;
                }

        .checkbox-group, .slider-group {
            margin-bottom: 10px;
            font-size: 0.9em;
        }

            .checkbox-group input {
                margin-right: 5px;
            }

        .slider-group {
            display: flex;
            flex-direction: column;
        }

            .slider-group label {
                margin-bottom: 4px;
            }

            .slider-group input[type="range"] {
                width: 100%;
            }

        .position-display, .scan-status {
            width: 100%;
            background-color: #e9ecef;
            text-align: center;
            padding: 5px;
            border-radius: 4px;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .anatomical-label {
            color: black;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 14px;
        }

        /* Tutorial menu styles */
        .tutorial-menu {
            max-width: 440px;
            margin: 40px auto;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 10px #dfe6e9;
            padding: 32px;
        }

            .tutorial-menu h2 {
                text-align: center;
            }

        .tutorial-list {
            list-style: none;
            padding: 0;
        }

            .tutorial-list li {
                margin: 18px 0;
            }

        .tutorial-btn {
            display: block;
            background: #0984e3;
            color: #fff;
            padding: 16px 0;
            border-radius: 6px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1em;
            text-align: center;
            transition: background 0.2s;
        }

            .tutorial-btn:hover {
                background: #74b9ff;
            }

        /* Tutorial overlay styles */
        .tutorial-highlight {
            box-shadow: 0 0 8px 3px #00b894 !important;
            outline: 2px solid #00b894 !important;
            z-index: 2000 !important;
            position: relative;
        }
    </style>
</head>
<body>
    <div class="controls-sidebar">
        <div class="sidebar-title">Camera / View</div>
        <div class="button-group">
            <button onclick="resetCamera()">Reset View</button>
            <button onclick="viewAxial()">Axial View</button>
            <button onclick="viewSagittal()">Sagittal View</button>
        </div>

        <div class="sidebar-title">Display Options</div>
        <div class="checkbox-group">
            <input type="checkbox" id="showAnatomicalLabelsCheckbox" onchange="toggleAnatomicalLabelsVisibility()" checked>
            <label for="showAnatomicalLabelsCheckbox">Show Anatomical Labels</label>
        </div>

        <div class="sidebar-title">Laser Options</div>
        <div class="checkbox-group">
            <input type="checkbox" id="lapLasersCheckbox" checked>
            <label for="lapLasersCheckbox">Show LAP Lasers</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="fixedGantryLasersCheckbox" checked>
            <label for="fixedGantryLasersCheckbox">Show Fixed Gantry Lasers</label>
        </div>

        <div class="sidebar-title">Laser Controls</div>
        <div class="button-group">
            <span>Lateral (X)</span>
            <button onclick="moveLasers(-1, 0, 0)">← Left</button>
            <button onclick="moveLasers(1, 0, 0)">Right →</button>
        </div>
        <div class="button-group">
            <span>Vertical (Y)</span>
            <button onclick="moveLasers(0, 1, 0)">↑ Up</button>
            <button onclick="moveLasers(0, -1, 0)">↓ Down</button>
        </div>
        <div class="button-group">
            <span>Laser Long. (Z)</span>
            <button onclick="moveLasers(0, 0, -1)">← In</button>
            <button onclick="moveLasers(0, 0, 1)">Out →</button>
        </div>
        <div class="button-group">
            <span>Laser Position</span>
            <span id="laserPositionDisplay" class="position-display">X:0.0, Y:0.0, Z:0.0</span>
        </div>

        <div class="sidebar-title">Couch Controls</div>
        <div class="button-group">
            <span>Lateral (X)</span>
            <button id="moveCouchXLeft" onclick="moveCouch(-1, 0, 0)">← Left</button>
            <button id="moveCouchXRight" onclick="moveCouch(1, 0, 0)">Right →</button>
        </div>
        <div class="button-group">
            <span>Vertical (Y)</span>
            <button id="moveCouchYUp" onclick="moveCouch(0, 1, 0)">↑ Up</button>
            <button id="moveCouchYDown" onclick="moveCouch(0, -1, 0)">↓ Down</button>
        </div>
        <div class="button-group">
            <span>Couch Long. (Z)</span>
            <button id="moveCouchZIn" onclick="moveCouch(0, 0, -1)">← In</button>
            <button id="moveCouchZOut" onclick="moveCouch(0, 0, 1)">Out →</button>
        </div>
        <div class="button-group">
            <span>Couch Position</span>
            <span id="couchPositionDisplay" class="position-display">X:0.0, Y:0.0, Z:0.0</span>
        </div>

        <div class="sidebar-title">Model Controls</div>
        <div class="button-group">
            <button id="rotateHumanBtn" onclick="rotateHuman180()" disabled>Rotate Patient 180°</button>
            <button onclick="resetHumanRotation()">Reset Patient Rotation</button>
        </div>  

        <div class="sidebar-title">Scan & Beam</div>
        <div class="button-group">
            <button id="halfScanBtn" onclick="startScan(halfScanTargetZ, 1500)">Half Scan (to Iso)</button>
            <button id="fullScanBtn" onclick="startScan(fullScanTargetZ, 3000)">Full Scan (In)</button>
        </div>
        <div class="button-group">
            <button id="stopScanBtn" onclick="stopScan()" disabled>Stop Scan/Rotation</button>
        </div>
        <div id="scanStatusDisplay" class="scan-status">Status: Idle</div>
        <div class="checkbox-group">
            <input type="checkbox" id="beamVisibilityCheckbox" onchange="toggleBeamVisibility()">
            <label for="beamVisibilityCheckbox">Show Treatment Beam</label>
        </div>
        <div class="button-group">
            <button id="rotateGantryBtn" onclick="toggleGantryRotation()">Rotate Gantry</button>
        </div>

        <div class="sidebar-title">Respiratory Motion</div>
        <div class="checkbox-group">
            <input type="checkbox" id="motionEnableCheckbox" onchange="toggleMotion()">
            <label for="motionEnableCheckbox">Enable Motion</label>
        </div>
        <div class="slider-group">
            <label for="motionAmplitudeSlider">Amplitude:</label>
            <input type="range" id="motionAmplitudeSlider" min="0" max="1.5" value="0.5" step="0.1" oninput="updateMotionParams()">
            <span id="motionAmplitudeValue">0.5</span> units
        </div>
        <div class="slider-group">
            <label for="motionSpeedSlider">Speed:</label>
            <input type="range" id="motionSpeedSlider" min="0.5" max="3.0" value="1.0" step="0.1" oninput="updateMotionParams()">
            <span id="motionSpeedValue">1.0</span> x
        </div>

        <div class="sidebar-title">Isocenter</div>
        <div class="button-group">
            <button id="setIsocenterBtn" onclick="setCurrentPosAsIsocenter()" style="background-color: #ffc107; color: black; width: 100%; padding: 6px 0;">Set Current Pos as Isocenter</button>
        </div>

        <div class="sidebar-title">Tutorials</div>
        <div class="button-group">
            <button onclick="document.getElementById('tutorialMenu').style.display='block'" style="width: 100%;">
                Open Tutorial Menu
            </button>
        </div>
    </div>

    <canvas id="c"></canvas>

    <div id="tutorialMenu" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%;
        background:rgba(0,0,0,0.5); z-index:9999; overflow:auto;">
        <div class="tutorial-menu">
            <h2>Tutorial Menu</h2>
            <ul class="tutorial-list">
                <li><a class="tutorial-btn" href="#" onclick="startTutorial('ctcomponents'); return false;">CT Machine Components</a></li>
                <li><a class="tutorial-btn" href="#" onclick="startTutorial('couch'); return false;">Couch Movement</a></li>
                <li><a class="tutorial-btn" href="#" onclick="startTutorial('isocenter'); return false;">Isocenter Localization</a></li>
                <li><a class="tutorial-btn" href="#" onclick="startTutorial('skinmarking'); return false;">Skin Marking Demo</a></li>
                <li><a class="tutorial-btn" href="#" onclick="startTutorial('dose'); return false;">Dose Calculation Demo</a></li>
            </ul>
            <p style="text-align:center; margin-top:30px;">
                <button onclick="document.getElementById('tutorialMenu').style.display='none'">✖ Close</button>
            </p>
        </div>
    </div>

    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
          }
        }
    </script>

    <script type="module">
        function getQSParam(name) {
            let params = new URLSearchParams(window.location.search);
            return params.get(name);
        }

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, camera, renderer, controls, clock;
        let labelRenderer;
        let lapLaserGroup, fixedGantryLaserGroup, laserGroup;
        let couchGroup, patientMesh, tumorMesh;
        let gantryGroup, tubeMesh, detectorMesh, gantryRingMesh;
        let treatmentBeamHelper;

        let upperArmL = null;
        let upperArmR = null;

        let _humanRotateAnimId = null;
        let _humanRotateAnimating = false;

        // New: separate inner + outer models and inner pivot
        let gantryInnerModel = null;
        let gantryOuterModel = null;
        let gantryInnerPivot = null; // pivot at gantry origin used to rotate only inner

        let userDefinedIsocenterPos = new THREE.Vector3(0, 5, 0);
        let gantryRotationAngle = 0;
        const gantryRotationSpeed = 0.03;
        let patientBaseY = 0;

        const laserMoveStep = 0.5;
        const couchMoveStep = 0.5;
        const longitudinalLimitIn = -15;
        const longitudinalLimitOut = 15;

        let couchAnimationRequestId = null;
        let gantryAnimationRequestId = null;
        let isScanning = false;
        let isGantryRotating = false;

        let motionEnabled = false;
        let motionAmplitude = 0.5;
        let motionSpeedFactor = 1.0;

        const halfScanTargetZ = 0;
        const fullScanTargetZ = longitudinalLimitIn;
        window.halfScanTargetZ = halfScanTargetZ;
        window.fullScanTargetZ = fullScanTargetZ;

        let laserPositionDisplay, couchPositionDisplay, scanStatusDisplay;
        let moveCouchButtons = [];
        let scanButtons = [];
        let stopScanBtn, rotateGantryBtn, beamVisibilityCheckbox;
        let motionEnableCheckbox, motionAmplitudeSlider, motionSpeedSlider;
        let motionAmplitudeValueSpan, motionSpeedValueSpan;
        let showAnatomicalLabelsCheckbox;

        const GANTRY_RADIUS = 8;
        const GANTRY_THICKNESS = 1.5;
        const TUBE_SIZE = 0.8;
        const DETECTOR_WIDTH = 1.5;
        const DETECTOR_HEIGHT = 0.5;
        const DETECTOR_DEPTH = 2.5;
        const BEAM_LENGTH = GANTRY_RADIUS * 1.5;
        const BEAM_FIELD_SIZE = 3;
        const TUMOR_RADIUS = 0.1;
        const PATIENT_CYLINDER_RADIUS = 1.2;
        const PATIENT_CYLINDER_HEIGHT = 12;

        let anatomicalLabelsCache = [];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc);
            camera = new THREE.PerspectiveCamera(75, (window.innerWidth - 220) / window.innerHeight, 0.1, 1000);
            clock = new THREE.Clock();

            const canvas = document.querySelector('#c');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth - 220, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth - 220, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.left = '220px';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            resetCamera();

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.7); dirLight1.position.set(10, 20, 15); dirLight1.castShadow = true; scene.add(dirLight1);
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5); dirLight2.position.set(-10, 15, -10); scene.add(dirLight2);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            createAlignmentLasers();
            createCouchAndPatient();
            createGantry(); // now loads Gantry_Inner + Gantry_Outer into gantryGroup
            createTreatmentBeam();
            createLAPLases();
            createFixedGantryLasers();

            // LAP lasers: set initial position halfway between gantry and patient couch
            const lapOriginZ = (longitudinalLimitOut + 0) / 2;
            const lapLaserInitialPos = new THREE.Vector3(0, userDefinedIsocenterPos.y, lapOriginZ);
            lapLaserGroup.position.copy(lapLaserInitialPos);
            userDefinedIsocenterPos.copy(lapLaserInitialPos);

            couchGroup.position.set(0, userDefinedIsocenterPos.y, longitudinalLimitOut);
            gantryGroup.position.copy(new THREE.Vector3(0, userDefinedIsocenterPos.y, 0));
            controls.target.copy(lapLaserGroup.position);

            setLaserLayering();

            laserPositionDisplay = document.getElementById('laserPositionDisplay');
            couchPositionDisplay = document.getElementById('couchPositionDisplay');
            scanStatusDisplay = document.getElementById('scanStatusDisplay');
            stopScanBtn = document.getElementById('stopScanBtn');
            rotateGantryBtn = document.getElementById('rotateGantryBtn');
            beamVisibilityCheckbox = document.getElementById('beamVisibilityCheckbox');
            motionEnableCheckbox = document.getElementById('motionEnableCheckbox');
            motionAmplitudeSlider = document.getElementById('motionAmplitudeSlider');
            motionSpeedSlider = document.getElementById('motionSpeedSlider');
            motionAmplitudeValueSpan = document.getElementById('motionAmplitudeValue');
            motionSpeedValueSpan = document.getElementById('motionSpeedValue');
            showAnatomicalLabelsCheckbox = document.getElementById('showAnatomicalLabelsCheckbox');
            scanButtons = [
                document.getElementById('halfScanBtn'),
                document.getElementById('fullScanBtn'),
                document.getElementById('setIsocenterBtn')
            ];
            moveCouchButtons = [
                document.getElementById('moveCouchXLeft'),
                document.getElementById('moveCouchXRight'),
                document.getElementById('moveCouchYUp'),
                document.getElementById('moveCouchYDown'),
                document.getElementById('moveCouchZIn'),
                document.getElementById('moveCouchZOut')
            ].filter(btn => btn !== null);

            updateLaserPositionDisplay();
            updateCouchPositionDisplay();
            updateScanStatus("Idle");
            setMovementAndScanButtonsEnabled(true);
            treatmentBeamHelper.visible = beamVisibilityCheckbox.checked;
            updateMotionParams();
            motionEnabled = motionEnableCheckbox.checked;
            toggleAnatomicalLabelsVisibility();

            // Laser visibility controls
            const lapLasersCheckbox = document.getElementById('lapLasersCheckbox');
            const fixedGantryLasersCheckbox = document.getElementById('fixedGantryLasersCheckbox');
            if (lapLasersCheckbox) lapLasersCheckbox.addEventListener('change', toggleLAPLasesVisibility);
            if (fixedGantryLasersCheckbox) fixedGantryLasersCheckbox.addEventListener('change', toggleFixedGantryLasersVisibility);
            // Ensure visibility matches initial state
            toggleLAPLasesVisibility();
            toggleFixedGantryLasersVisibility();

            window.addEventListener('resize', onWindowResize, false);
            animate();
            console.log("4D CT Sim Init complete with separate Gantry_Inner / Gantry_Outer loader");
        }

        function createAlignmentLasers() {
            laserGroup = new THREE.Group();
        }

        function createLAPLases() {
            lapLaserGroup = new THREE.Group();
            const lapLaserLength = 12;
            const lapLaserMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2, transparent: true, opacity: 0.7 });
            lapLaserGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-lapLaserLength / 2, 0, 0), new THREE.Vector3(lapLaserLength / 2, 0, 0)]), lapLaserMaterial));
            lapLaserGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, -lapLaserLength / 2), new THREE.Vector3(0, 0, lapLaserLength / 2)]), lapLaserMaterial));
            lapLaserGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -lapLaserLength / 2, 0), new THREE.Vector3(0, lapLaserLength / 2, 0)]), lapLaserMaterial));
            scene.add(lapLaserGroup);
        }

        function createFixedGantryLasers() {
            fixedGantryLaserGroup = new THREE.Group();
            fixedGantryLaserGroup.position.set(0, 0, 0);
            const fixedLaserLength = 14;
            const fixedLaserMaterial = new THREE.LineBasicMaterial({ color: 0x3399ff, linewidth: 2, transparent: true, opacity: 0.7 });
            fixedGantryLaserGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-fixedLaserLength / 2, 0, 0), new THREE.Vector3(fixedLaserLength / 2, 0, 0)]), fixedLaserMaterial));
            fixedGantryLaserGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, -fixedLaserLength / 2), new THREE.Vector3(0, 0, fixedLaserLength / 2)]), fixedLaserMaterial));
            fixedGantryLaserGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -fixedLaserLength / 2, 0), new THREE.Vector3(0, fixedLaserLength / 2, 0)]), fixedLaserMaterial));
            // attach to gantryGroup (outer/inner visuals will be children of gantryGroup)
            if (gantryGroup) gantryGroup.add(fixedGantryLaserGroup);
        }

        function setLaserLayering() {
            if (lapLaserGroup) lapLaserGroup.children.forEach(line => line.renderOrder = 2);
            if (fixedGantryLaserGroup) fixedGantryLaserGroup.children.forEach(line => line.renderOrder = 3);
            if (gantryGroup) gantryGroup.renderOrder = 0;
            if (couchGroup) couchGroup.renderOrder = 0;
        }

        function toggleLAPLasesVisibility() {
            const lapLasersCheckbox = document.getElementById('lapLasersCheckbox');
            if (lapLaserGroup && lapLasersCheckbox) lapLaserGroup.visible = lapLasersCheckbox.checked;
        }
        function toggleFixedGantryLasersVisibility() {
            const fixedGantryLasersCheckbox = document.getElementById('fixedGantryLasersCheckbox');
            if (fixedGantryLaserGroup && fixedGantryLasersCheckbox) fixedGantryLaserGroup.visible = fixedGantryLasersCheckbox.checked;
        }

        function createAnatomicalLabel(text, x, y, z) {
            const div = document.createElement('div');
            div.className = 'anatomical-label';
            div.textContent = text;
            const label = new CSS2DObject(div);
            label.position.set(x, y, z);
            anatomicalLabelsCache.push(label);
            return label;
        }

        window.toggleAnatomicalLabelsVisibility = function () {
            if (!showAnatomicalLabelsCheckbox || !anatomicalLabelsCache) return;
            const isVisible = showAnatomicalLabelsCheckbox.checked;
            anatomicalLabelsCache.forEach(label => {
                if (label && label.element) {
                    label.element.style.display = isVisible ? '' : 'none';
                    label.visible = isVisible;
                }
            });
        }

        function createCouchAndPatient() {
            couchGroup = new THREE.Group();
            const couchTopGeo = new THREE.BoxGeometry(0, 0, 0);
            const couchTopMat = new THREE.MeshStandardMaterial({ transparent: true, opacity: 0 });
            const couchTop = new THREE.Mesh(couchTopGeo, couchTopMat);
            couchTop.receiveShadow = true;
            couchGroup.add(couchTop);

            // attempt to load patient GLB (unchanged behavior)
            const loader = new GLTFLoader();
            const humanPath = 'CT_Assets/Human_Body_Transparent.glb';

            loader.load(humanPath, (gltf) => {
                const model = gltf.scene || gltf.scenes[0];
                model.traverse((node) => { if (node.isMesh) { node.castShadow = node.receiveShadow = true; } });
                const humanBbox = new THREE.Box3().setFromObject(model);
                const size = humanBbox.getSize(new THREE.Vector3());
                let scaleFactor = 10;
                model.scale.setScalar(scaleFactor);
                humanBbox.setFromObject(model);
                const newSize = humanBbox.getSize(new THREE.Vector3());
                patientBaseY = -2
                model.rotation.x = Math.PI / -2;
                humanBbox.setFromObject(model);
                const offsetY = patientBaseY - humanBbox.min.y;
                model.position.set(0, offsetY, 30);
                couchGroup.add(model);
                patientMesh = model;

                // enable rotate button once patient model is present
                const rotateHumanBtn = document.getElementById('rotateHumanBtn');
                if (rotateHumanBtn) rotateHumanBtn.disabled = false;

                upperArmL = model.getObjectByName('upper_armL') || model.getObjectByName('upper_arm_l') || model.getObjectByName('UpperArm.L');
                upperArmR = model.getObjectByName('upper_armR') || model.getObjectByName('upper_arm_r') || model.getObjectByName('UpperArm.R');

                upperArmL.rotation.x = Math.PI / -2;
                upperArmL.rotation.y = Math.PI / -4;
                upperArmR.rotation.x = Math.PI / -2;
                upperArmR.rotation.y = Math.PI / 4;

                //// --- list all bones / bone-like nodes to console for debugging ---
                //const boneNodes = [];
                //model.traverse((n) => {
                //    if (n.isBone || n.type === 'Bone') boneNodes.push(n);
                //});

                //if (boneNodes.length > 0) {
                //    console.groupCollapsed(`Model Bones (${boneNodes.length})`);
                //    boneNodes.forEach(b => console.log(b.name || b.uuid, b));
                //    console.groupEnd();
                //    // expose for console access
                //    window.modelBones = boneNodes;
                //} else {
                //    // fallback: find nodes whose names look like bones
                //    const candidates = [];
                //    model.traverse((n) => {
                //        if (n.name && /upper_arm\.l|upper_arm\.r|arm|humerus|radius|ulna|clavicle|scapula|bone|spine|femur|tibia|fibula|shoulder|hand|foot/i.test(n.name)) {
                //            candidates.push(n);
                //        }
                //    });
                //    console.groupCollapsed(`Bone-like nodes (${candidates.length})`);
                //    candidates.forEach(n => console.log(n.name || n.uuid, n));
                //    console.groupEnd();
                //    window.modelBones = candidates;
                //}

                const tumorGeo = new THREE.SphereGeometry(TUMOR_RADIUS, 16, 16);
                const tumorMat = new THREE.MeshStandardMaterial({ color: 0xff4136, emissive: 0x440000 });
                tumorMesh = new THREE.Mesh(tumorGeo, tumorMat);
                tumorMesh.position.set(0, 2.7, 0.2);
                tumorMesh.castShadow = true;
                model.add(tumorMesh);

                const labelDepthOffset = newSize.z / 2 + 0.7;
                const labelWidthOffset = newSize.x / 2 + 0.5;
                const labelPatientYPos = patientBaseY;
                const labelPatientAntYPos = patientBaseY + newSize.y / 2 + 0.4;
                const labelPatientPostYPos = (0.5 / 2) + 0.15;

                couchGroup.add(createAnatomicalLabel("Head", 0, labelPatientYPos, -labelDepthOffset));
                couchGroup.add(createAnatomicalLabel("Feet", 0, labelPatientYPos, labelDepthOffset));
                couchGroup.add(createAnatomicalLabel("Anterior", 0, labelPatientAntYPos, 0));
                couchGroup.add(createAnatomicalLabel("Posterior", 0, labelPatientPostYPos, 0));
                couchGroup.add(createAnatomicalLabel("Left", labelWidthOffset, labelPatientYPos, 0));
                couchGroup.add(createAnatomicalLabel("Right", -labelWidthOffset, labelPatientYPos, 0));
            }, undefined, (err) => {
                console.error("Failed to load GLB patient, falling back to cylinder:", err);
                const patientGeo = new THREE.CylinderGeometry(PATIENT_CYLINDER_RADIUS, PATIENT_CYLINDER_RADIUS, PATIENT_CYLINDER_HEIGHT, 20);
                const patientMat = new THREE.MeshStandardMaterial({ color: 0xb0c4de, transparent: true, opacity: 0.6 });
                const fallbackPatient = new THREE.Mesh(patientGeo, patientMat);
                fallbackPatient.rotation.x = Math.PI / 2;
                patientBaseY = (0.5 / 2) + PATIENT_CYLINDER_RADIUS;
                fallbackPatient.position.y = patientBaseY;
                fallbackPatient.castShadow = true;
                fallbackPatient.receiveShadow = true;
                couchGroup.add(fallbackPatient);
                patientMesh = fallbackPatient;

                tumorMesh = new THREE.Mesh(new THREE.SphereGeometry(TUMOR_RADIUS, 16, 16), new THREE.MeshStandardMaterial({ color: 0xff4136, emissive: 0x440000 }));
                tumorMesh.position.set(0, 0, 0);
                patientMesh.add(tumorMesh);

                const labelPatientYPos = patientBaseY;
                const labelPatientAntYPos = patientBaseY + PATIENT_CYLINDER_RADIUS + 0.4;
                const labelPatientPostYPos = (0.5 / 2) + 0.15;
                const labelDepthOffset = PATIENT_CYLINDER_HEIGHT / 2 + 0.7;
                const labelWidthOffset = PATIENT_CYLINDER_RADIUS + 0.5;

                couchGroup.add(createAnatomicalLabel("Head", 0, labelPatientYPos, -labelDepthOffset));
                couchGroup.add(createAnatomicalLabel("Feet", 0, labelPatientYPos, labelDepthOffset));
                couchGroup.add(createAnatomicalLabel("Anterior", 0, labelPatientAntYPos, 0));
                couchGroup.add(createAnatomicalLabel("Posterior", 0, labelPatientPostYPos, 0));
                couchGroup.add(createAnatomicalLabel("Left", labelWidthOffset, labelPatientYPos, 0));
                couchGroup.add(createAnatomicalLabel("Right", -labelWidthOffset, labelPatientYPos, 0));
            });

            scene.add(couchGroup);
        }

        // createGantry now loads Gantry_Outer + Gantry_Inner separately.
        function createGantry() {
            gantryGroup = new THREE.Group();
            scene.add(gantryGroup);

            const loader = new GLTFLoader();

            // Helper to scale/center a loaded model and attach to gantryGroup.
            function processAndAttachModel(model, options = {}) {
                model.traverse(n => { if (n.isMesh) { n.castShadow = n.receiveShadow = true; } });
                const bbox = new THREE.Box3().setFromObject(model);
                const size = bbox.getSize(new THREE.Vector3());
                const desiredDiameter = GANTRY_RADIUS * 6;

                // Allow an explicit scale override via options.scale.
                // If not provided, compute a uniformScale based on model size (existing behaviour).
                let uniformScale;
                if (typeof options.scale === 'number') {
                    uniformScale = options.scale;
                } else {
                    uniformScale = 1;
                    if (size.x > 0) uniformScale = desiredDiameter / size.x;
                    if (uniformScale <= 0) uniformScale = 0.01;
                    // keep a reasonable clamp for automatically computed scales
                    uniformScale = Math.min(Math.max(uniformScale, 0.0005), 10);
                }

                model.scale.setScalar(uniformScale);

                bbox.setFromObject(model);
                const center = bbox.getCenter(new THREE.Vector3());
                model.position.sub(center);
                // small orientation adjustment to match previous behavior
                model.rotateY(Math.PI / -2);

                // optional offset
                if (options.offsetX) model.position.x += options.offsetX;
                gantryGroup.add(model);

                // return useful metadata
                return { model, bbox, size, uniformScale };
            }

            // Load outer shell (visual ring / housing)
            loader.load('CT_Assets/Gantry_Outer.glb', (gltf) => {
                try {
                    const model = gltf.scene || gltf.scenes[0];
                    const meta = processAndAttachModel(model, { offsetX: 39, scale: 10 });
                    gantryOuterModel = model;
                    console.log('Gantry Outer loaded, scale:', meta.uniformScale);
                    // ensure fixedGantry lasers are parented to gantryGroup (already added earlier)
                } catch (e) {
                    console.warn('Error processing Gantry_Outer', e);
                }
            }, undefined, (err) => {
                console.warn('Failed to load Gantry_Outer.glb', err);
            });

            // Load inner tube (this is the rotating piece — we'll put it under an inner pivot so only it spins)
            loader.load('CT_Assets/Gantry_Inner.glb', (gltf) => {
                try {
                    const model = gltf.scene || gltf.scenes[0];

                    // heuristics to find the actual tube mesh (if any)
                    let foundTube = null;
                    model.traverse((n) => {
                        if (!n.isMesh) return;
                        const name = (n.name || '').toLowerCase();
                        if (!foundTube && (name.includes('cyl') || name.includes('tube') || name.includes('xray') || name.includes('gantry') || name.includes('td'))) {
                            foundTube = n;
                        }
                    });

                    // scale + center and add temporarily to gantryGroup so world matrices are correct
                    const meta = processAndAttachModel(model, { offsetX: 0 });

                    // At this point `model` is a child of `gantryGroup` so world matrices are valid.
                    // Compute tube world position (fallback to model origin if we couldn't detect the tube)
                    const tubeWorldPos = new THREE.Vector3();
                    if (foundTube) {
                        foundTube.getWorldPosition(tubeWorldPos);
                    } else {
                        // fallback: use model's world position (center)
                        model.getWorldPosition(tubeWorldPos);
                    }

                    // Create a pivot located at the tube center expressed in gantryGroup local space.
                    // We'll add the pivot to gantryGroup and then attach the inner model to the pivot
                    // using Object3D.attach to preserve the model's world transform.
                    const pivot = new THREE.Object3D();
                    const pivotLocal = gantryGroup.worldToLocal(tubeWorldPos.clone());
                    pivot.position.copy(pivotLocal);
                    gantryGroup.add(pivot);

                    // Attach the model under the pivot while preserving its world transform.
                    // attach() moves the object into the new parent and updates its local transform so
                    // it keeps the same world transform — exactly what we need.
                    pivot.attach(model);

                    // Save references
                    gantryInnerPivot = pivot;
                    gantryInnerModel = model;

                    if (foundTube) {
                        tubeMesh = foundTube;
                        console.log('Gantry Inner: tube mesh assigned by heuristic:', foundTube.name || foundTube.id);
                    } else {
                        const maybe = model.getObjectByName('Cylinder') || model.getObjectByName('Cylinder__0') || model.getObjectByName('cylinder');
                        if (maybe) {
                            tubeMesh = maybe;
                            console.log('Gantry Inner: tube assigned by explicit name:', maybe.name);
                        }
                    }

                    // Reparent treatment beam to the inner model so it rotates with the tube
                    if (treatmentBeamHelper) {
                        if (treatmentBeamHelper.parent) treatmentBeamHelper.parent.remove(treatmentBeamHelper);
                        gantryInnerModel.add(treatmentBeamHelper);
                    }

                    // adjust camera / controls target as before
                    const bbox = new THREE.Box3().setFromObject(gantryGroup);
                    const bsize = bbox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(bsize.x, bsize.y, bsize.z);
                    camera.position.set(userDefinedIsocenterPos.x + Math.max(25, maxDim * 1.5), userDefinedIsocenterPos.y + Math.max(20, maxDim * 0.6), userDefinedIsocenterPos.z + Math.max(30, maxDim * 1.0));
                    controls.target.copy(userDefinedIsocenterPos);

                    console.log('Gantry Inner loaded, attached to pivot at tube center. scale:', meta.uniformScale);
                } catch (e) {
                    console.warn('Error processing Gantry_Inner', e);
                }
            }, undefined, (err) => {
                console.warn('Failed to load Gantry_Inner.glb', err);
            });

            // If both fail, the rest of the system continues to work with procedural fallback (unchanged)
        }

        function createTreatmentBeam() {
            const coneHeight = GANTRY_RADIUS / 4;
            const radiusAtIso = BEAM_FIELD_SIZE / 2;
            const coneBaseRadius = (radiusAtIso / GANTRY_RADIUS) * coneHeight;
            const beamGeo = new THREE.ConeGeometry(coneBaseRadius, coneHeight, 32, 1, true);
            beamGeo.rotateX(Math.PI);
            beamGeo.translate(0, -3, 0);
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00, transparent: true, opacity: 0.25,
                depthWrite: false, side: THREE.DoubleSide
            });
            treatmentBeamHelper = new THREE.Mesh(beamGeo, beamMat);
            treatmentBeamHelper.visible = false;

            // add initially to gantryGroup; when inner loads the code reparents beamHelper to inner model
            if (gantryGroup) gantryGroup.add(treatmentBeamHelper);
        }

        // moveLasers, setCurrentPosAsIsocenter, moveCouch, scanning and animation functions remain unchanged
        window.moveLasers = function (dx, dy, dz) {
            if (!lapLaserGroup || isScanning || isGantryRotating) return;
            const moveVector = new THREE.Vector3(dx * laserMoveStep, dy * laserMoveStep, dz * laserMoveStep);
            lapLaserGroup.position.add(moveVector);
            userDefinedIsocenterPos.copy(lapLaserGroup.position);
            updateLaserPositionDisplay();
            controls.target.copy(lapLaserGroup.position);
        }

        window.setCurrentPosAsIsocenter = function () {
            if (!lapLaserGroup || isScanning || isGantryRotating) return;
            userDefinedIsocenterPos.copy(lapLaserGroup.position);
            updateLaserPositionDisplay();
            controls.target.copy(userDefinedIsocenterPos);
            console.log("Isocenter set to world:", userDefinedIsocenterPos);
        }

        window.moveCouch = function (dx, dy, dz) {
            if (isScanning || isGantryRotating) { stopAllAnimations(); console.log("Scan/Rotation stopped by manual couch movement."); }
            if (!couchGroup) return;
            const newPos = couchGroup.position.clone();
            newPos.x += dx * couchMoveStep;
            newPos.y += dy * couchMoveStep;
            newPos.z += dz * couchMoveStep;
            newPos.z = Math.max(longitudinalLimitIn + userDefinedIsocenterPos.z, Math.min(longitudinalLimitOut + userDefinedIsocenterPos.z, newPos.z));
            couchGroup.position.copy(newPos);
            updateCouchPositionDisplay();
        }

        function setMovementAndScanButtonsEnabled(enabled) {
            moveCouchButtons.forEach(button => { if (button) button.disabled = !enabled; });
            scanButtons.forEach(button => { if (button) button.disabled = !enabled; });
            if (stopScanBtn) stopScanBtn.disabled = !(isScanning || isGantryRotating);
            if (rotateGantryBtn) rotateGantryBtn.disabled = isScanning;
        }

        // Helper: determine which object should be rotated for gantry actions
        function getGantryRotationTarget() {
            // Rotate the inner pivot (if present) so the outer shell remains static and inner spins about gantry origin.
            return gantryInnerPivot || gantryInnerModel || gantryGroup;
        }

        function animateScanMovement(targetZrelativeToIso, duration = 1500) {
            if (!couchGroup || !gantryGroup || isScanning || isGantryRotating) return;
            stopAllAnimations();
            const targetWorldZ = userDefinedIsocenterPos.z + targetZrelativeToIso;
            const startZ = couchGroup.position.z;
            const distanceZ = targetWorldZ - startZ;
            if (Math.abs(distanceZ) < 0.01) return;

            isScanning = true; isGantryRotating = true;
            setMovementAndScanButtonsEnabled(false);
            updateScanStatus("Scanning...");
            if (treatmentBeamHelper) treatmentBeamHelper.visible = true;

            const startTime = performance.now();
            function stepCouch() {
                if (!isScanning) { couchAnimationRequestId = null; return; }
                const currentTime = performance.now(); const elapsedTime = currentTime - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                couchGroup.position.z = Math.max(longitudinalLimitIn + userDefinedIsocenterPos.z, Math.min(longitudinalLimitOut + userDefinedIsocenterPos.z, startZ + distanceZ * progress));
                updateCouchPositionDisplay();
                if (progress < 1) { couchAnimationRequestId = requestAnimationFrame(stepCouch); }
                else { couchAnimationRequestId = null; if (!gantryAnimationRequestId && isScanning) { stopAllAnimations(true); } }
            }
            function stepGantry() {
                if (!isGantryRotating) { gantryAnimationRequestId = null; return; }
                gantryRotationAngle += gantryRotationSpeed;
                if (gantryRotationAngle > Math.PI * 2) gantryRotationAngle -= Math.PI * 2;
                const rotTarget = getGantryRotationTarget();
                rotTarget.rotation.z = gantryRotationAngle;
                if (isScanning || isGantryRotating) { gantryAnimationRequestId = requestAnimationFrame(stepGantry); }
                else { gantryAnimationRequestId = null; }
            }
            couchAnimationRequestId = requestAnimationFrame(stepCouch);
            gantryAnimationRequestId = requestAnimationFrame(stepGantry);
        }

        window.startScan = function (targetZrelativeToIso, duration) { animateScanMovement(targetZrelativeToIso, duration); }

        window.toggleGantryRotation = function () {
            if (isScanning) return;
            if (isGantryRotating) { stopAllAnimations(); }
            else {
                isGantryRotating = true;
                setMovementAndScanButtonsEnabled(false);
                updateScanStatus("Rotating Gantry...");
                if (beamVisibilityCheckbox.checked && treatmentBeamHelper) { treatmentBeamHelper.visible = true; }
                function stepGantry() {
                    if (!isGantryRotating) { gantryAnimationRequestId = null; return; }
                    gantryRotationAngle += gantryRotationSpeed;
                    if (gantryRotationAngle > Math.PI * 2) gantryRotationAngle -= Math.PI * 2;
                    const rotTarget = getGantryRotationTarget();
                    rotTarget.rotation.z = gantryRotationAngle;
                    gantryAnimationRequestId = requestAnimationFrame(stepGantry);
                }
                gantryAnimationRequestId = requestAnimationFrame(stepGantry);
                rotateGantryBtn.textContent = "Stop Rotation";
            }
        }

        window.rotateHuman180 = function () {
            if (!patientMesh) { console.warn('rotateHuman180: patientMesh not loaded'); return; }
            if (_humanRotateAnimating) return;
            _humanRotateAnimating = true;

            const duration = 400; // ms
            const startY = patientMesh.rotation.y;
            const endY = startY + Math.PI; // 180 degrees
            const startTime = performance.now();

            function easeInOut(t) {
                // smoothstep style easing
                return 0.5 - 0.5 * Math.cos(Math.PI * Math.min(Math.max(t, 0), 1));
            }

            function step(now) {
                const t = (now - startTime) / duration;
                const eased = easeInOut(t);
                patientMesh.rotation.y = startY + (endY - startY) * eased;
                if (t < 1) {
                    _humanRotateAnimId = requestAnimationFrame(step);
                } else {
                    _humanRotateAnimId = null;
                    _humanRotateAnimating = false;
                }
            }

            _humanRotateAnimId = requestAnimationFrame(step);
        };

        window.resetHumanRotation = function () {
            if (!patientMesh) { console.warn('resetHumanRotation: patientMesh not loaded'); return; }
            if (_humanRotateAnimId) { cancelAnimationFrame(_humanRotateAnimId); _humanRotateAnimId = null; }
            _humanRotateAnimating = false;
            patientMesh.rotation.y = 0;
        };

        window.stopAllAnimations = function (scanFinishedNaturally = false) {
            const wasScanning = isScanning; const wasRotating = isGantryRotating;
            isScanning = false; isGantryRotating = false;
            if (treatmentBeamHelper) treatmentBeamHelper.visible = beamVisibilityCheckbox.checked;
            if (couchAnimationRequestId) { cancelAnimationFrame(couchAnimationRequestId); couchAnimationRequestId = null; }
            if (gantryAnimationRequestId) { cancelAnimationFrame(gantryAnimationRequestId); gantryAnimationRequestId = null; }
            setMovementAndScanButtonsEnabled(true);
            rotateGantryBtn.textContent = "Rotate Gantry";
            if (!scanFinishedNaturally && (wasScanning || wasRotating)) { updateScanStatus("Stopped"); }
            else if (scanFinishedNaturally) { updateScanStatus("Scan Complete"); }
            else { updateScanStatus("Idle"); }
        }
        window.stopScan = window.stopAllAnimations;

        window.toggleMotion = function () {
            motionEnabled = motionEnableCheckbox.checked;
            if (!motionEnabled && patientMesh) {
                patientMesh.position.y = patientBaseY;
            }
        }
        window.updateMotionParams = function () {
            motionAmplitude = parseFloat(motionAmplitudeSlider.value);
            motionSpeedFactor = parseFloat(motionSpeedSlider.value);
            if (motionAmplitudeValueSpan) motionAmplitudeValueSpan.textContent = motionAmplitude.toFixed(1);
            if (motionSpeedValueSpan) motionSpeedValueSpan.textContent = motionSpeedFactor.toFixed(1);
        }

        function updateLaserPositionDisplay() {
            if (lapLaserGroup && laserPositionDisplay)
                laserPositionDisplay.textContent = `X:${lapLaserGroup.position.x.toFixed(1)}, Y:${lapLaserGroup.position.y.toFixed(1)}, Z:${lapLaserGroup.position.z.toFixed(1)}`;
        }
        function updateCouchPositionDisplay() {
            if (couchGroup && couchPositionDisplay)
                couchPositionDisplay.textContent = `X:${couchGroup.position.x.toFixed(1)}, Y:${couchGroup.position.y.toFixed(1)}, Z:${couchGroup.position.z.toFixed(1)}`;
        }
        function updateScanStatus(statusText) {
            if (scanStatusDisplay) scanStatusDisplay.textContent = `Status: ${statusText}`;
        }

        window.resetCamera = function () {
            camera.position.set(userDefinedIsocenterPos.x + 25, userDefinedIsocenterPos.y + 20, userDefinedIsocenterPos.z + 30);
            if (controls) controls.target.copy(userDefinedIsocenterPos);
        }
        window.viewAxial = function () {
            camera.position.set(userDefinedIsocenterPos.x, userDefinedIsocenterPos.y + 45, userDefinedIsocenterPos.z);
            if (controls) controls.target.copy(userDefinedIsocenterPos);
        }
        window.viewSagittal = function () {
            camera.position.set(userDefinedIsocenterPos.x + 45, userDefinedIsocenterPos.y, userDefinedIsocenterPos.z);
            if (controls) controls.target.copy(userDefinedIsocenterPos);
        }

        window.toggleBeamVisibility = function () {
            if (treatmentBeamHelper) {
                treatmentBeamHelper.visible = beamVisibilityCheckbox.checked;
                if (isScanning || isGantryRotating) { treatmentBeamHelper.visible = true; }
            }
        }

        function updateTreatmentBeamPosition() {
            // prefer inner pivot as beam parent so local conversions are consistent
            const beamParent = gantryInnerPivot || gantryInnerModel || gantryGroup;
            if (beamParent && tubeMesh && treatmentBeamHelper) {
                const tubeWorldPos = new THREE.Vector3();
                tubeMesh.getWorldPosition(tubeWorldPos);
                const local = beamParent.worldToLocal(tubeWorldPos.clone());
                treatmentBeamHelper.position.copy(local);
                treatmentBeamHelper.rotation.set(0, 0, 0);
                treatmentBeamHelper.rotateX(Math.PI);
            } else if (gantryGroup && !tubeMesh && treatmentBeamHelper) {
                treatmentBeamHelper.position.copy(new THREE.Vector3(0, GANTRY_RADIUS, 0));
                treatmentBeamHelper.rotation.set(0, 0, 0);
                treatmentBeamHelper.rotateX(Math.PI);
            }
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            const newWidth = window.innerWidth - 220;
            const newHeight = window.innerHeight;
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
            if (labelRenderer) {
                labelRenderer.setSize(newWidth, newHeight);
                const canvas = document.querySelector('#c');
                if (canvas) {
                    labelRenderer.domElement.style.left = canvas.offsetLeft + 'px';
                    labelRenderer.domElement.style.top = canvas.offsetTop + 'px';
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            if (motionEnabled && patientMesh) {
                const motionOffset = Math.sin(elapsedTime * motionSpeedFactor * Math.PI) * motionAmplitude;
                patientMesh.position.y = patientBaseY + motionOffset;
            } else if (!motionEnabled && patientMesh && patientMesh.position.y !== patientBaseY) {
                patientMesh.position.y = patientBaseY;
            }
            updateTreatmentBeamPosition();
            if (renderer && controls && scene && camera) {
                controls.update();
                renderer.render(scene, camera);
                if (labelRenderer) {
                    labelRenderer.render(scene, camera);
                }
            }
        }
        init();

        window.addEventListener('DOMContentLoaded', () => {
            const tutorialKey = getQSParam('tutorial');
            if (tutorialKey) {
                if (window.startTutorial) {
                    window.startTutorial(tutorialKey);
                }
            }
        });

    </script>
</body>
</html>